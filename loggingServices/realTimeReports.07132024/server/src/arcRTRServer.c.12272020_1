/*-----------------------------------------------------------------------
Program:	arcRTRServer.c
Author:		Aumtech, Inc
Date:		12-9-2020
-----------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/types.h>
#include <dirent.h>

// #include <rpc/des_crypt.h>

#include "ss.h"
#include "gaUtils.h"

#include "log_defs.h"

#define START_STR				"## START ##"
#define END_STR					"## END"			// partial string
#define END_AND_REMOVE_STR		"REMOVE SHADOW"		// partial string

//#define MAXBUFF	512
//#define	DIRECTORY_CREATION_PERMS	0755
//#define	OPEN_MASK			0000

/* #define DEBUG */
//static char	LogFile1[PATHSZ];
//static char	LogFile2[PATHSZ];
//static char	Dir1[PATHSZ];
//static char	BaseDir[PATHSZ];
//char		msgbuf[256];


typedef struct
{
	char		workDir[128];
	char		processedDir[128];
	char		uname[32];
	char		filename[128];
	char		adjustedFilename[256];
	char		shadowFilename[256];
	char		prevShadowFilename[256];
	int			shadowIndex;
	int			command;			// 1=start, 0=stop
} SInfo;

char		*gIspBase;
SInfo		sInfo;

//void		Exit();
//static int	lValidateDirectory(char *iDirectory, char *oErrorMsg);
static int parseCmdStr(char *zData);
static int 	init();
static int 	processFiles();
static int createAdjustedFilename();
static void printSInfo();

main(int argc, char *argv[])
{
	static char	mod[]="main";
	char		databuf[256];

	int			rc, i;
	long		recvdBytes;

	static char	gaLogDir[256];
	
	if(argc == 2 && (strcmp(argv[1], "-v") == 0))
	{
		fprintf(stdout, 
			"Aumtech's Logging Services (%s).\n"
			"Version 2.3.  Compiled on %s %s.\n", argv[0], __DATE__, __TIME__);
		exit(0);
	}
	sprintf(gaLogDir,"%s/LOG", (char *)getenv("ISPBASE"));
	rc=gaSetGlobalString("$PROGRAM_NAME", argv[0]);
	rc=gaSetGlobalString("$LOG_DIR", gaLogDir);
	rc=gaSetGlobalString("$LOG_BASE", argv[0]);

	if ((rc = init()) != 0)
	{
		exit(1);
	}
	
	if ((rc = ss_Init(argc, argv)) != ss_SUCCESS)
	{
		gaVarLog(mod, 0,"[%d] ss_Init() failed.  rc=%d.", __LINE__, rc);
		exit(3);
	}
	gaVarLog(mod, 1,"[%d] ss_Init() succeeded.  rc=%d.", __LINE__, rc);
	
	rc = processFiles();

	ss_Exit();
	exit(3);
	
}

/*-----------------------------------------------------------------------------
  ---------------------------------------------------------------------------*/
static int processFiles()
{
	static char	mod[]="processFiles";
	char		data[1024+1];
	long		numBytes;
	char		*p;
	int			rc;
	FILE		*fp;
	char		workFile[256];
	char		processedFile[256];
	int			notEnd;

	for(;;)
	{
		memset(data, 0, sizeof(data));
		gaVarLog(mod, 1,"[%d] Calling ss_RecvData() for command.", __LINE__);
		rc=ss_RecvData(180, 512, data, &numBytes);
		if ( ( rc == -2 ) || ( numBytes == 0 ) )
		{
			gaVarLog(mod, 1,"[%d]  ss_RecvData() timed out.", __LINE__);
			sleep(2);
			continue;
		}
		if ( rc < 0 ) 
		{
			gaVarLog(mod, 0,"[%d]  ss_RecvData() failed.  rc=%d", __LINE__, rc);
			break;
		}

		gaVarLog(mod, 1,"[%d] Successfully received (%d:%s) from server.", __LINE__, numBytes, data);
	
		if ( (rc = parseCmdStr(data)) != 0)
		{
			; // TODO: handle error
		}
	
		if ( sInfo.command ) // START
		{
			if ( (rc = createAdjustedFilename()) != 0 )
			{
				; // TODO: handle error
			}
			printSInfo();
	
			sprintf(workFile, "%s/%s", 
					sInfo.workDir, sInfo.adjustedFilename);
			sprintf(processedFile, "%s/%s", 
					sInfo.processedDir, sInfo.adjustedFilename);
			if ((fp = fopen(workFile, "w")) == NULL)
			{
				gaVarLog(mod, 0, "[%d] Unable to open %s for output.  [%d, %s] ",
					"Unable to receive (%s).", __LINE__,  errno, strerror(errno), workFile);
				return(-1);
			}
			gaVarLog(mod, 1, "[%d] Successfully opened destination file (%s).", __LINE__, workFile);
	
			// Now receive the data and write it
			notEnd=1;
			while (notEnd)
			{
				memset(data, 0, sizeof(data));
				if ((rc=ss_RecvData(60, 1024, data, &numBytes)) != ss_SUCCESS)
				{
					gaVarLog(mod, 0,"[%d] ss_RecvData() of transfer type failed.  rc=%d.", __LINE__, rc);
					fclose(fp);
					return(-1);
				}
				gaVarLog(mod, 1,"[%d] Successfully received (%s) from server.", __LINE__, data);
			
				if ( ! strstr(data, END_STR ) )
				{
					fprintf(fp, "%s", data);
					continue;
				}
	
				// we have the end string.  close it up.
				fclose(fp);
				if ( (rc = rename(workFile, processedFile)) != 0)
				{
					gaVarLog(mod, 0, "[%d] Failed to rename (%s) to (%s).  [%d, %s]", __LINE__,
							workFile, processedFile);
					// TODO
				}
				gaVarLog(mod, 1, "[%d] Moved (%s) to (%s).", __LINE__, workFile, processedFile);
	
				if ( sInfo.prevShadowFilename[0] != '\0' )
				{
					sprintf(workFile, "%s/%s", sInfo.workDir, sInfo.prevShadowFilename);
					if ( access(workFile, F_OK) == 0 )
					{
						unlink(workFile);
						gaVarLog(mod, 1, "[%d] Removed (%s).", __LINE__, workFile);
					}
				}
	
				gaVarLog(mod, 0, "[%d] DJB: data:(%s) END_AND_REMOVE_STR(%s)", __LINE__, data, END_AND_REMOVE_STR);
				if ( ! strstr(data, END_AND_REMOVE_STR ) )
				{
					sprintf(workFile, "%s/%s", sInfo.workDir, sInfo.shadowFilename);
					if ((fp = fopen(workFile, "w")) == NULL)
					{
						gaVarLog(mod, 0, "[%d] Unable to open %s for output.  [%d, %s] ", __LINE__,
							"Unable to create shadow file (%s)", workFile);
					}
					fclose(fp);
					gaVarLog(mod, 0, "[%d] Created shadow file (%s).", __LINE__, workFile);
				}
				notEnd = 0;
			}
		}
	}

	return(0);
} // END: processFiles

/*-----------------------------------------------------------------------------
  ---------------------------------------------------------------------------*/
static int createAdjustedFilename()
{
	static char		mod[]="createAdjustedFilename";
	int				rc;
 	DIR				*dir;
	struct dirent	*dirEntry;     
	char			searchFile[256];
	int				index;
	char			*p;

	if ( (dir = opendir(sInfo.workDir)) == NULL)
	{
		gaVarLog(mod, 0, "[%d] Unable to open directory (%s).  Cannot process (%s)", __LINE__,
			sInfo.workDir, sInfo.filename);
		return(-1);
	}

	//
	// ex.  looking for shadow.testsys.CDR.2020-Dec07-13.for.<index>
	//
	sprintf(searchFile, "shadow.%s.%s", sInfo.uname, sInfo.filename);
	index = -1;
	gaVarLog(mod, 1, "[%d] Searching %s for %s", __LINE__, sInfo.workDir, searchFile);
    while (dirEntry = readdir (dir))
	{
		if (strstr(dirEntry->d_name, searchFile) != (char *)NULL)
		{
			// found it.  Now get the index.
			p=strrchr(dirEntry->d_name, '.');
			p++;
			index=atoi(p);
			break;
		}
	}
    (void) closedir (dir);

	if ( index == -1 ) // not found
	{
		sInfo.shadowIndex = 0;
		sprintf(sInfo.adjustedFilename, "%s.%s.%d",
				sInfo.uname, sInfo.filename, sInfo.shadowIndex);
		sprintf(sInfo.shadowFilename, "shadow.%s", sInfo.adjustedFilename);
		sInfo.prevShadowFilename[0] = '\0';
		gaVarLog(mod, 1, "[%d] DJB: not found - sInfo.adjustedFilename(%s)", __LINE__, sInfo.adjustedFilename);
	}
	else
	{
		sInfo.shadowIndex = index + 1;
		sprintf(sInfo.adjustedFilename, "%s.%s.%d",
				sInfo.uname, sInfo.filename, sInfo.shadowIndex);
		gaVarLog(mod, 1, "[%d] DJB: found - index=%d, sInfo.shadowIndex=%d  sInfo.adjustedFilename(%s)", __LINE__, 
				index, sInfo.shadowIndex, sInfo.adjustedFilename);

		sprintf(sInfo.shadowFilename, "shadow.%s", sInfo.adjustedFilename);
		gaVarLog(mod, 1, "DJB: found - sInfo.shadowFilename(%s)", __LINE__, sInfo.shadowFilename);
		sprintf(sInfo.prevShadowFilename, "shadow.%s.%s.%d",
				sInfo.uname, sInfo.filename, sInfo.shadowIndex - 1);
		gaVarLog(mod, 1, "DJB: found - sInfo.prevShadowFilename(%s)", __LINE__, sInfo.prevShadowFilename);
	}

	return(0);
} // END: createAdjustedFilename()

/*-----------------------------------------------------------------------------
  ---------------------------------------------------------------------------*/
static int parseCmdStr(char *zData)
{
	static char	mod[]="parseCmdStr";
	char		buf[256];
	char		*p;

	sprintf(buf, "%s", zData);

	if ( (p=strchr(buf, '|')) == (char *)NULL)
	{
		gaVarLog(mod, 0, "[%d] Invalid command string received (%s).  Unable to parse.  Where's the uname?", __LINE__,
			zData);
		return(-1);
	}
	*p='\0';
	sprintf(sInfo.uname, "%s", buf);
	p++;

	sprintf(buf, "%s", p);

	if ( (p=strchr(buf, '|')) == (char *)NULL)
	{
		gaVarLog(mod, 0, "[%d] Invalid command string received (%s).  Unable to parse. Where's the filename?", __LINE__,
			zData);
		return(-1);
	}
	*p='\0';
	sprintf(sInfo.filename, "%s", buf);
	p++;

	if ( strstr(p, START_STR) )
	{
		sInfo.command = 1;
	}
	else if ( strstr(p, END_STR) )
	{
		sInfo.command = 0;
	}
	else
	{
		gaVarLog(mod, 0, "[%d] Invalid command string received (%s).  Unable to parse. What's the command?", __LINE__,
			zData);
		return(-1);
	}
	return(0);
	

} // END: parseCmdStr()

/*-----------------------------------------------------------------------------
  ---------------------------------------------------------------------------*/
static int init()
{
	static char	mod[]="init";
	char		*base;
	int			rc;
	char		buf[256];

    if ((gIspBase = getenv ("ISPBASE")) == NULL)
    {
		gaVarLog(mod, 0, "[%d] Unable to get ISPBASE env variable. Set it and retry.  Unable to continue.", __LINE__);
        return (-1);
    }
	gaVarLog(mod, 0, "[%d] Starting.", __LINE__);

    if ((base = getenv ("HOME")) == NULL)
    {
		gaVarLog(mod, 0, "[%d] Unable to get HOME env variable. Set it and retry.  Unable to continue.", __LINE__);
		return(-1);
	}
	if ( base[strlen(base) - 1] == '/' )
	{
		base[strlen(base) - 1] = '\0';
	}

	memset((SInfo *)&sInfo, '\0', sizeof(sInfo));

	sprintf(buf, "%s/RTR", base);
	if (access (buf, F_OK|R_OK ) < 0)
	{
		if(errno == ENOENT)
		{
			if (mkdir(buf, 0755) < 0)
			{
				gaVarLog(mod, 0, "[%d] mkdir (%s) failed. Unable to create directory. [%d, %s].  Correct and retry.", __LINE__,
						buf, errno, strerror(errno));
				return(-1);
			}
		}
        else
        {
            gaVarLog(mod, 0, "[%d] Unable to access directry (%s). [%d, %s].  Correct and retry.", __LINE__,
                        buf, errno, strerror(errno));
            return(-1);
        }
	}

	
	sprintf(sInfo.workDir, "%s/work", buf);
	sprintf(sInfo.processedDir, "%s/processed", buf);

	if (access (sInfo.workDir, F_OK|R_OK ) < 0)
	{
		if(errno == ENOENT)
		{
			if (mkdir(sInfo.workDir, 0755) < 0)
			{
				gaVarLog(mod, 0, "[%d] mkdir (%s) failed. Unable to create directory. [%d, %s].  Correct and retry.", __LINE__,
						sInfo.workDir, errno, strerror(errno));
				return(-1);
			}
		}
        else
        {
            gaVarLog(mod, 0, "[%d] Unable to access directry (%s). [%d, %s].  Correct and retry.", __LINE__,
                        sInfo.workDir, errno, strerror(errno));
            return(-1);
        }
	}
	if (access (sInfo.processedDir, F_OK|R_OK ) < 0)
	{
		if(errno == ENOENT)
		{
			if (mkdir(sInfo.processedDir, 0755) < 0)
			{
				gaVarLog(mod, 0, "[%d] mkdir (%s) failed. Unable to create directory. [%d, %s].  Correct and retry.", __LINE__,
						sInfo.processedDir, errno, strerror(errno));
				return(-1);
			}
		}
        else
        {
            gaVarLog(mod, 0, "[%d] Unable to access directry (%s). [%d, %s].  Correct and retry.", __LINE__,
                        sInfo.processedDir, errno, strerror(errno));
            return(-1);
        }
	}

	return(0);
} // END: init()

/*-----------------------------------------------------------------------------
  ---------------------------------------------------------------------------*/
static void printSInfo()
{
	static char mod[] = "printSInfo";

	gaVarLog(mod, 1, "[%d] workDir(%s) processedDir(%s), uname(%s), filename(%s), adjustedFilename(%s), ",
			"shadowFilename(%s), prevShadowFilename(%s), shadowIndex(%d), command(%d)", 
			sInfo.workDir, 
			sInfo.processedDir,
			sInfo.uname,
			sInfo.filename,
			sInfo.adjustedFilename,
			sInfo.shadowFilename,
			sInfo.prevShadowFilename,
			sInfo.shadowIndex,
			sInfo.command);

} // END: printSInfo()
