/*-----------------------------------------------------------------------------
Program:	isp_baseresp.c
Purpose: This is general purpose scheduler to schedule Telecom Service 
	 application, TCP/IP Services application, SNA Services application.
Author:		Mahesh Joshi.
Date created :	11/21/95 Mahesh Joshi.
Update:		02/21/96 Mahesh Joshi.
Update:		03/06/96 G. Wenzel updated this header
Update:		03/25/96 Mahesh Joshi. Put message for program maximum instances
Update:		05/09/96 G. Wenzel changed isdncfg to analogcfg in load_telec...
Update:		05/23/96 M. Joshi added functions to start network services.
Update:		05/23/96 G. Wenzel fixed startup of Network Services.
Update:		05/29/96 M. Joshi added code for dynamic allocation of port.
Update:		06/28/96 M. Joshi added code for changing application name.
Update:		06/30/96 M. Joshi changed code to increase length of resource
			 name from 12 to 17.
Update:		07/02/96 M. Joshi changed code to keep information of DID in
			 shared memory.
Update:		07/03/96 M. Joshi changed "-S" argument to pass ISDN Type
			 GV_ISDN_TYPE
Update:		07/15/96 M. Joshi added code to allow multiple dnis in schedule
			 table for same static destination with different rules.
Update:		07/15/96 M. Joshi change ISP_MAX_HBEAT to 61 in resp.h 
Update:		08/28/96 M. Joshi add mechanism to cleanup leftover message on
			 dynamic manager message queue. 
Update:		09/12/96 M. Bhide Added a mesg_recv() in remove_msgs to remove 
				  pid_dead from the dynamic manager queue.
Update:		11/14/96 M. Bhide changes made in get_free_port routine to 
			make sure that the port is both FREE and IDLE. 
Update:		11/14/96 M. Bhide changed APPL_STATUS to STATUS_BUSY when
			get_free_port was sucessful. 
Update:		11/15/96 M. Bhide changed APPL_STATUS to STATUS_INIT when
			dyn_mgr was fired
Update:		11/17/96 M. Bhide added ASSIGNED:port on REQUEST_PORT &
			checked for the match on RELEASE_PORT
Update:		11/26/96 M. Bhide changed "no Dynamic Manager" message
				from NORMAL to DETAIL
Update:		11/26/96 M. Bhide added write_fld to make APPL_SIGNAL 1
Update:		12/23/96 M. Bhide using correct message que to cleanup
Update:		12/24/96 M. Bhide application is correctly removed from
				application_instance_manager database
Update:		02/01/97 M. Bhide updated the shared memory table after
				RESERVE_PORT was freed.
Update:		01/13/97 M. Bhide updated the shared memory table pid
				after port was marked RESERVED
Update:		01/24/97 M. Bhide dyn_mgr_que messages are removed only 
				if dyn_mgr is running on that port.
Update:		03/03/97 M. Bhide changes in mesg_recv1 routine. 
Update:		03/03/97 M. Bhide changes in clean_msgs_dead_appl routine. 
			to clean dyn_mgr_appl array.
Update:		04/08/97 sja	Added license checking routines.
Update:		04/10/97 sja	Removed validLicense routine from source code.
Update:		04/28/97 MPB	added dynmgr_pid array, changes in cleanup_app &
				process_dynmgr_request.
Update:		07/24/97 MPB	addedd REQUEST_OVERLAY code
Update:		07/24/97 MPB	addedd ability to put * for machine name
Update:	08/12/97 M Bhide Added defines for Message Ids & SNMP_SendAlarm calls  
Update:	08/13/97 M Bhide Changed Parameters to Log messages 
Update:	10/05/97 sja	Added version information
Update:	10/22/97 mpb	Commented -S & -h parameters for analog application
Update:	01/15/98 mpb	added atoi(port) >= 0
Update:	01/19/98 mpb	removed function load_teecom_config_file() and
			set_default_parameter() and put it in TEL_Common.c
			since it is needed by Transfer & Bridge.
Update:	02/18/98 mpb	Made changes in NAP_TIME , [watch_dog] for loop.
Update:	02/08/98 mpb	Made LogMsg Normal from Detail for the scheduling 
			entries those are ignored.
Update:	04/30/98 mpb	Moved INIT from after fork & exec to before fork. 
Update:	06/05/98 mpb	Changed NULL to 0 for strcmp calls & NULL to -1 for
			read and time calls. 
Update:	06/07/98 mpb	Commented ISP_PROGRAM_FIND code from cleanup_app.
Update:	06/07/98 mpb	Removed read_fld from check_kill_app.
Update: 06/24/98 ak 	Added code for Resource Manager
Update:	09/30/98 mpb	Added check for STATUS_CHNOFF when giving RESERVED port.
Update:	10/10/98 mpb	Added get_available_port routine to give port based
			on usage.
Update:	10/13/98 mpb	Changed token1 from 20 to 50 in launch_applications.
Update:	01/20/99 mpb	Added RLT flag in exec for TEL object.
Update:	03/22/99 gpw added Licensed_Resources, Turnkey_License, arcValidLicense
Update: 04/02/99 mpb    Added code to check if pid was dead before removing
                        messages in msg q, in launch_applications.
Update:	04/05/99 gpw states LogMsg is a macro that uses log_msg (log_resp.c)
Update: 04/05/99 gpw removed check_xvox_proc 
Update: 04/13/99 gpw modified arcValidLicense to try 10 times to get mac addr. 
Update: 06/18/99 gpw made updates to run ResourceMgr from Global Exec
Update: 07/09/99 mpb while killing applications kill only pids not equals 0.
Update: 07/09/99 apj changed atoi to sscanf in look_for_dynmgr_file routine.
Update: 07/09/99 apj In reevaluate_port_status routine, if port is RESERVED,
		     change it's status to POFF.
Update: 07/14/99 mpb In start_netserv routine set variable start_net_serv to 0
			if network services file does not exist.
Update: 07/19/99 apj In checkAlarmHandlerFile routine, do processing only if
		     <alarm_file> has been modified.
Update: 07/26/99 mpb Commented checkAlarmHandlerFile() routine.
Update: 07/26/99 gpw Added turnkey license processing.
Update: 07/28/99 mpb Commented STATUS_BUSY in update_dyn_mgr_appl routine.
Update: 07/28/99 gpw No longer log specific cause of license failure.
Update: 08/02/99 gpw Removed debug statement for handshake.
Update: 09/01/99 mpb Changed sleep 1 to util_sleep(0, 500). 
Update: 09/01/99 mpb Added code to remove the message from dynamic manager que. 
			code is added in MQUE_CLEANUP_TIME check.
Update: 10/28/99 mpb Added MAX_DEAD_PROCS. 
Update: 11/08/99 gpw Rename this file from isp_newresp.c to isp_baseresp.c
Update: 02/22/00 apj Added convertStarToUnixPatternMatch, stringMatch functions.
Update: 02/23/00 mpb In process_dyn_mgr routine added memset for application.
Update: 03/22/00 mpb Added getLogparmValue & changeLogMode to change logging
	from normal to verbose or verbose to normal based on .Global.cfg file.
Update:	05/25/00 gpw Added comment: changeLogMode rtn is in resp_log.c. 
Update:	06/01/00 mpb Added read_fld with APPL_STATUS in cleanup_app routine. 
Update:	06/21/00 mpb Changed code regarding REQUEST_OVERLAY. 
Update:	08/01/00 mpb Added check before updating APPL_STATUS in 
		update_application & cleanup_app routines. 
Update:	08/01/00 mpb Added else condition to change APPL_STATUS to CHOFF in
		 reevaluate_port_state() routine.
Update:	09/11/00 sja In mesg_recv() and mesg_recv1(), changed if errno == 35
			to errno == ENOMSG for LINUX
Update: 2000/10/07 sja 4 Linux: Checked for SIG_ERR in signal() call
Update: 2000/10/27 gpw Updated licensing for Linux
Update:	11/14/00 mpb Changed Application spawning too rapidly message.
Update:	11/29/00 mpb Added code to check pid before removing any
		messages in the message que.
Update:	11/30/00 mpb Added code to pass MAX_NUM_APPL_FIRE as a parameter.
Update:	11/30/00 mpb Moved updating of dynmgr_pid from if REQUEST_APPLICATION
			to after fork & exec.
Update:	12/11/00 mpb Added strncmp(ASSIGNED:) in launch_application routine
		in case of DYN_MGR.
Update:	12/11/00 mpb dynmgr_pid array is updated after fork & exec if 
		object is TEL.
Update:	12/21/00 mpb in remove_msgs routine moved if(TEL) before network
		services check. 
Update:	02/13/01 mpb Added lookForDnisMatch routine.
Update:	04/05/01 gpw added license check for TEL_START in arcValidLicense
Update:	04/10/01 gpw fixed start date check in arcValidLicense.
Update:	04/17/01 mpb in process_dyn_mgr_request added static_dest in acct_name
		field for REQUEST_PORT.
Update:	05/08/01 mpb Added code to start spxdr_server.
Update:	05/17/01 mpb Added code to start OCSMgr.
Update:	07/09/01 mpb Changed SIGINT to SIGTERM for killing OCSMgr.
Update:	07/12/01 mpb Fixed "killing OCSMgr" message.
Update: 07/13/01 mpb uncommented checkAlarmHandlerFile routine.
Update: 07/13/01 mpb Added code create pid file and put pid in it.
Update: 09/24/01 mpb Added utlGetField to solve sscanf issue.
Update: 10/03/01 mpb Made changes to StartSpxdr routine to read .spxdr.pid file.
Update: 11/15/01 mpb Added 3115 & 3116 to send SNMP alarm..
Update: 12/10/01 mpb Killing OCSMgr wirh SIGKILL instead of SIGTERM.
Update: 01/19/02 mpb Added RSM_REQUEST_PORT & RSM_RELEASE_PORT.
Update: 01/25/02 mpb Added starting of ArcGDynMgr.
Update: 01/28/02 mpb Added Killing of ArcGDynMgr.
Update: 01/28/02 mpb Added concept of Skipped port.
Update:	01/29/02 mpb Removed code to start spxdr_server.
Update:	02/09/02 mpb Added code so that * doesn't match with static app.
Update:	05/01/02 mpb Added check for MVPDynMgr.
Update:	05/11/02 mpb Passing Licensed Resources when ArcGDynMgr is started.
Update:	07/23/02 mpb Removed ADD or DELETE INSTANCE if static App.
Update:	09/09/02 mpb Changed SIGTERM to SIGKILL for no heartbeat.
Update:	09/23/02 apj Added group hunting code.
Update:	12/05/02 mpb Removed load_telecom_config_file & set_default_config 
			routines, since they are not used.
Update:	02/06/03 mpb Fixed MR# 1207.
--------------------------------------------------------------------------------
Message ID Defines - to match the corresponding msgs in include/resp_msg.h 
ISP_EENV	3001
ISP_ESHM_AT	3003
ISP_ESHMID	3005
ISP_EMSGQID	3007
ISP_ESTOP	3009
ISP_EACTIVITY	3010
ISP_ERECV_MESG	3017
ISP_EEXECL	3038
ISP_ESTART_NET	3039
ISP_ESTART_ACCESS	3040
ISP_EFORK	3041
------------------------------------------------------------------------------- 
Files		: BNS.h, ISPSYS.h, shm_def.h, resp.h, resp_msg.h, support.c
Modules Called	: see prototype section.
Libararies Used	: support.c  : read_fld(), write_fld().
		  log_mgr.c  : log_msg().
------------------------------------------------------------------------------*/
#include "ISPSYS.h"                     /* Shared memory/Message Queue id */
#include "BNS.h"                        /* shared memory variables */
#include "resp.h"                       /* global variables definations */
#include "shm_def.h"                    /* shared memory field information */
#include "resp_msg.h"                   /* error messages definations */
#include "arc_snmpdefs.h"               /* ARC SNMP group & object defines */
#include <regex.h>

#define	DEBUG_TABLES
/*
#define DEBUG_RULES
#define DEBUG
*/

#define RESACT_INTERVAL		120	/* 2 min */
#define DYNMGR_INTERVAL		600	/* 10 min */

typedef struct {                        /* message structure */
        long    mesg_type2;             /* message type */
        char    mesg_data2[512];        /* message text */
} Mesg2;

int	OCSMgr_pid = 0;
int	ArcGDynMgr_pid = 0;
int	start_OCSMgr = 0;
int	start_ArcGDynMgr = 0;
static	int	SNMP_Group_Id;
static 	int	Licensed_Resources, Turnkey_License;

#define DIALOGIC1
/* external function prototype */
extern  int write_arry();
extern	int write_fld();
extern	int read_arry();
extern	int read_fld();

#define HUNT_GROUP_CFG "huntGroups.cfg"
#define MAX_NUM_SECTIONS 20
#define DEFAULT_RULE "FIRSTAVAILABLE"

#define RULE_FIRST_AVAILABLE 1
#define RULE_ASCENDING 2
#define RULE_ASCENDING_EVEN 3
#define RULE_ASCENDING_ODD 4
#define RULE_DESCENDING 5
#define RULE_DESCENDING_EVEN 6
#define RULE_DESCENDING_ODD 7

struct GivePortRule
{
	char section[50];
	int rule;
	int lastPortGiven;
} gGivePortRule[MAX_NUM_SECTIONS];

int  gMaxSections;

/* local function prototype */
static  int 	get_license_file_name(char *license_file, char *err_msg);
static	void	resp_shutdown();
static	void	cleanup_app(int, int);
static	void	init_array();
static	void	update_shmem();
static	int 	check_environment(int);
static	int 	set_object_path(int);
static	int 	check_configuration_tables(int);
static	int 	fill_vecs();
static	int	launch_applications(int, char *, int[], int[]);
static	int 	SHMGET();
static	int 	MSGGET();
static	int	create_msgq_shmem();
static	int	remove_msgqs();
static	int	check_responsibility();
static	int	clean_msgs_for_dead_appl();
static	int	process_dyn_mgr_request();
static	int	load_tables();
static	int	load_shmem_tabl();
static	int	load_resource_table();
static	int	load_schedule_table();
static	int	load_appref_table();
static	int	load_pgmref_table();
static	int	find_application();
static	int	check_data_token();
static	int	check_date_time_rule();
static	int	inform_dyn_mgr();
static	int	check_update_table_request();
static	int	get_field();
static	int	remove_msgs();
static	int	mesg_recv();
static	int 	application_instance_manager();
static	int 	set_resource_type_flag();
static	int 	set_resource_state_flag();
static	int	update_application();
static	int	find_pu_name();
static	void 	load_parameter_configuration();
static	int	kill_all_app();
static	void 	check_kill_app();
static	int	start_netserv();
static	void	check_net_config();
static	int	start_sna_access();
static	void	get_free_port();
static	int 	set_access_pid();
static	int 	update_dyn_mgr_appl();
static	int	update_DNIS(int , char *);
static	int	StartResourceMgr();
static 	int arcValidLicense(char *, int, int *, int *, char *);
static  void see_if_ResourceMgr_should_run();
static	int	StartOCSMgr();
static	int	StartArcGDynMgr();
void convertStarToUnixPatternMatch(char *parmStarString, char *parmResultString);
int stringMatch(char *iPattern, char *iString);

/*------------------------------------------------------------------------------
This routine is called when the application gets killed/terminated. This module updates the variable indicating the death of the application.
------------------------------------------------------------------------------*/
void cleanup_app(app_pid, appl_no)
{
int	stat, i, j;
char	program_name[MAX_PROGRAM];
static	char	ModuleName[] = "cleanup_app";
char	res_id[30];
Mesg	mesg1;
char	*ptr, *ptr1;
char	field_name[30];
int	dyn_pid;
char	status_str[10];

sprintf(log_buf, "Entering cleanup_app, app_pid %d, appl_no %d", app_pid, appl_no);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

pid_dead = app_pid;

/* if access terminated inform user */
if (object == SNA)
	{	
	if (access_pid == pid_dead)
		{
		sprintf(log_buf, "Received kill signal for access pid = %d", pid_dead);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		LogMsg(ModuleName,ISP_DEBUG_NORMAL,"Responsibility(): Exiting");
		/* kill all application that are running */
		/* Mahesh commented following code acees pid is not correct */
		/*
		kill_all_app();
		exit (0);
		*/
		}
	}
if(pid_dead == appl_pid[appl_no])
	{		/* found it */
	appl_stat_arry[appl_no] = 0;	/* update the field to indicate */
 					/* so that it can be re-started */
 	for(j = 0; j < MAX_DEAD_PROCS; j++)
 		{      
 		if(dead_application[j] == -1)
 			{
      			dead_application[j] = pid_dead;
 	  		/* store the application pid */
			break;
 			}
 		}
	if(j == MAX_DEAD_PROCS)
                {
                sprintf(log_buf,
                "Failed to add pid %d to dead application array",pid_dead);
                LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
                }
	/* read program name and resource */
	(void)read_fld(tran_tabl_ptr, appl_no, APPL_NAME, program_name);     
	(void)read_fld(tran_tabl_ptr, appl_no, APPL_RESOURCE, res_id);     
	/* application name could be in dynamic manager database */
	/* so look into dynamic manager application database */
	/* program name could be dynamic manager */
	if (object == TEL)
		{
		sprintf(log_buf, "found dead pid %d, program_name %s, res_id %s", app_pid, program_name, res_id);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		field_name[0] = '\0';
		if(strcmp(resource[appl_no].res_usage, RESERVE_PORT) == 0)
			{
			sprintf(field_name, "%s", RESERVE_PORT);
			ptr = tran_tabl_ptr;
			ptr += (appl_no*SHMEM_REC_LENGTH);
					/* position the pointer to the field */
			ptr += vec[APPL_NAME-1];/* application start index */
			ptr1 = ptr;
			(void) memset(ptr1, ' ', MAX_APPL_NAME);
			ptr += (MAX_APPL_NAME - strlen(field_name));
			(void) memcpy(ptr, field_name, strlen(field_name));
			res_status[appl_no].status = FREE; 
			sprintf(log_buf, "RESERVE Port Freed, pid %d, program_name %s, res_id %s", app_pid, program_name, res_id);
			LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
			}
		} /* for telecom object only */
	if((object == TEL) && (strcmp(resource[appl_no].res_state,"STATIC")==0) && (strcmp(resource[appl_no].res_type,"ISDN")==0))
			;
	else
		application_instance_manager(ISP_DELETE_INSTANCE, program_name, res_id);
	read_fld(tran_tabl_ptr, appl_no, APPL_STATUS, status_str);     
	if((atoi(status_str)!=STATUS_OFF)&&(atoi(status_str)!=STATUS_CHNOFF))
		write_fld(tran_tabl_ptr, appl_no, APPL_STATUS, STATUS_KILL);
	(void)write_fld(tran_tabl_ptr, appl_no, APPL_API, 0); 
	(void)write_fld(tran_tabl_ptr, appl_no, APPL_PID, 0); 
	(void)write_fld(tran_tabl_ptr, appl_no, APPL_SIGNAL, 2);
	update_DNIS(appl_no, "0000000000");
	}

if (object == TEL)
	{
	/* to cleanup leftover message of application on message queue */
	if(strcmp(resource[appl_no].res_type, "ISDN") == 0 && strcmp(resource[appl_no].res_state, "DYN_MGR") == 0)
		{
		if(dynmgr_pid[appl_no] > 0)
			{	
			if(kill(dynmgr_pid[appl_no], 0) == -1)
				{
				if(errno == ESRCH)
					{ /*No process*/
					mesg1.mesg_type = dynmgr_pid[appl_no];	
					/* message of dynamic manager type */
					mesg1.mesg_data[0] = '\0';
					mesg_recv(dyn_mqid, &mesg1);
					}
				}
			}
		res_status[appl_no].status = FREE; 
		}
	}
return;
} /* cleanup_app */


int main(argc, argv)
int	argc;
char	*argv[];
{
static	char	ModuleName[] = "main";
int	i, j, sec_cnt;
int	tran_sig[MAX_PROCS];	/* (field 10) to store the signal status */
int	tran_status[MAX_PROCS];	/* to store the status of application */
time_t	hbeat_time;
time_t	curr_time;			/* to store the current time */
time_t	que_time;			/* to store the queue time */
time_t	appl_off_time;			/* to store the hang test time */
time_t	resact_time;			/* to store the chk resact table */
time_t	dynmgr_time;			/* to store the chk dynmgr file */
int	hbeat_interval=0;
char	off_appl_name[512];
char	off_res_name[30];
char	last_api_name[30];
struct	sigaction	sig_act, sig_oact;
int	no_sleep = 0;
int	port_rc, portState;
int	rc;
char	failureReason[256];
Mesg	msg1;
int	type;
char	report_mode[10];
int	numOfTimesAppFired = 0;
FILE	*fp;
char	respPidFile[32];

if(argc == 2 && (strcmp(argv[1], "-v") == 0))
{
	fprintf(stdout, "%s - %s - %s\n", argv[0], __DATE__, __TIME__);
	exit(0);
}

/* set heartbeat seconds and set object name */
switch(argc)
	{
	case	4:
			numOfTimesAppFired = atoi(argv[3]);
	case	3:
		if((atoi(argv[2]) > ISP_MIN_HBEAT) && (atoi(argv[2]) < ISP_MAX_HBEAT))
			{
			hbeat_interval = (atoi(argv[2])) * 60;  /* secs */
			}
		else
			{
			hbeat_interval = ISP_DEFAULT_HBEAT * 60; /* default */
			sprintf(log_buf, "WARNING : kill time should be  %d < kill time < %d, Setting kill time to default = %d Min.",  ISP_MIN_HBEAT, ISP_MAX_HBEAT, ISP_DEFAULT_HBEAT);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			}
		/* please don't put break here */
	case	2:
		if (strcmp(argv[1], TELECOM_STR) == 0)
			{
			object = TEL;
 			SNMP_Group_Id = SNMPG_TEL;
			sprintf(object_name, "%s", "Telecom");
			}
		else if (strcmp(argv[1], SNA_STR) == 0)
			{
			object = SNA;
 			SNMP_Group_Id = SNMPG_SNA;
			sprintf(object_name, "%s", "SNA");
			}
		else if (strcmp(argv[1], TCP_STR) == 0)
			{
			object = TCP;
			SNMP_Group_Id = SNMPG_TCP;
			sprintf(object_name, "%s", "TCP");
			}
		else
			{
			fprintf(stderr, "Server type %s not supported : Usage: %s <TEL/SNA/TCP> [<kill time min>]\n", argv[1], argv[0]);
			sprintf(log_buf, ISP_EOBJ, argv[1]);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			exit (1);
			}
		break;
	default :
		fprintf(stderr, "Usage : %s <Object Name> <kill time interval>\n",argv[0]);
		sprintf(log_buf, ISP_EUSAGE, argv[0]);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		exit (1);
	} /* switch */

if(numOfTimesAppFired == 0)
	numOfTimesAppFired = MAX_NUM_APPL_FIRE;
else
	{
	sprintf(log_buf, "Num of times application will be fired in 300 seconds is set to %d, default is 25", numOfTimesAppFired);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	}
rc = arcValidLicense(argv[1],1,&Turnkey_License,&Licensed_Resources,log_buf);
if (rc != 0)
{
	fprintf(stderr, "%s: LICENSE FAILURE. %s\n", argv[1], log_buf);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, "License failure. See nohup.out.");
	exit(0);
}

sprintf(resp_name, "%s", argv[0]);
if (Turnkey_License)
	sprintf(log_buf, 
	"Starting Responsibility for %s server in turnkey mode...", argv[1]);
else
	sprintf(log_buf, "Starting Responsibility for %s server...", argv[1]);
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);

if (check_responsibility() != ISP_SUCCESS)	/* check if object is running */
	{
	exit (1);
	}

sprintf(respPidFile, "%s.pid", resp_name);
if ((fp=fopen(respPidFile, "w+")) == NULL)
	;
else
	{
	fprintf(fp, "%d", getpid());
	fclose(fp);
	}

sprintf(object_code, "%s", argv[1]);
sprintf(log_buf, ISP_EHBEAT, hbeat_interval);
LogMsg(ModuleName, ISP_DEBUG_DETAIL,log_buf);

/* check environment for given object */
if (check_environment(object) != ISP_SUCCESS)
	exit (1);

/* set directory structure for object */
if (set_object_path(object) != ISP_SUCCESS)
	exit (1);

/* check if all configuration file for the given object exists */
if (check_configuration_tables(object) != ISP_SUCCESS)
	exit (1);

/* initialize the table to maintain application terminated pid's and 
dynamic manager application pid array */
init_array();

/* Remove any existing shared memory segment and/or message ques. */
if (remove_msgqs(object) != ISP_SUCCESS)
	exit (1);

/* Create required shared memory segments and the message queues.  */
if (create_msgq_shmem(object) != ISP_SUCCESS)
	exit (1);

/* set shutdown function */
(void) signal(SIGTERM, resp_shutdown);

/* set death of child function */
sig_act.sa_handler = NULL;
sig_act.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT;
if (sigaction(SIGCHLD, &sig_act, &sig_oact) != 0)
	{
	sprintf(log_buf, "sigaction(SIGCHLD, SA_NOCLDWAIT): system call failed. errno=%d.", errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	exit(-1);
	} 
if (signal(SIGCHLD, SIG_IGN) == SIG_ERR || sigset(SIGCLD, SIG_IGN) == -1)
	{
	sprintf(log_buf, "signal(SIGCHLD, SIG_IGN): system call failed. errno=%d.", errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	exit(-1);
	} 

/* attach shared memory */
if ((tran_tabl_ptr = shmat(tran_shmid, 0, 0)) == (char *) -1)
	{			 /* attach the shared memory segment */
	sprintf(log_buf, ISP_ESHM_AT, GV_shm_key, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 	check_and_send_snmp_trap(3003, log_buf, SNMP_Group_Id);
	exit(-1);
	}

(void) check_update_table_request();	
/* this will store the time file last modified */

/* Load all configuration tables into memory */
if (load_tables(schedule_tabl, resource_tabl, appref_tabl, pgmref_tabl) != ISP_SUCCESS)
	{
	exit (1);
	}

readRulesFromCfg();

if(object == TEL)
	{
	/* load resact table */
	port_rc=loadResactTable(failureReason);
	if(port_rc != 0) 
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, failureReason);
	}

/* start network services if configured */
check_net_config();
if (start_net_serv == 1)	
	{
	start_netserv();
	}

if(start_ResMgr == 1)
	{
	StartResourceMgr();
	}

rc = access("OCSMgr", F_OK);
if(rc < 0)
	{
	sprintf(log_buf, "Can't start OCSMgr,  errno %d", errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}
else
	start_OCSMgr = 1;
if(start_OCSMgr == 1)
	{
	StartOCSMgr();
	}
rc = access("ArcGDynMgr", F_OK);
if(rc < 0)
	{
		;
	}
else
	start_ArcGDynMgr = 1;
if(start_ArcGDynMgr == 1)
	{
	StartArcGDynMgr();
	}

if (object == SNA)
	{
	start_sna_access();
	}

/* Load the resource and scheduling tables into the shared memory segments */
if (load_shmem_tabl(tran_shmid) != ISP_SUCCESS)
	exit (1);

sprintf(log_buf, "%s", "Telecom Services startup complete.");
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
check_and_send_snmp_trap(3115, log_buf, SNMP_Group_Id);

tran_proc_num = strlen(tran_tabl_ptr)/SHMEM_REC_LENGTH;

for(i=0; i<tran_proc_num; i++)	/* initialize the status vector */
	appl_stat_arry[i] = 0;  /* to indicate no application started */

/* Update the status bit fields in the shared memory */
(void)write_arry(tran_tabl_ptr, APPL_STATUS, appl_stat_arry);

/* This routine reads fields from shared memory table into given variables. */
(void) fill_vecs(tran_tabl_ptr, appl_pid);
					/* reads pid from shared memory */

/* initialize all start time process */
for(i=0; i < MAX_PROCS; i++)	
	count[i] = 0;

/* start application(s) */	
(void) launch_applications(tran_proc_num, tran_tabl_ptr, 
			appl_stat_arry, appl_pid);

if (time(&hbeat_time) == -1)
	{
	sprintf(log_buf, "Failed to get system time. errno=%d.", errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}
	
resact_time = hbeat_time;	/* initialize resact_time */	
dynmgr_time = hbeat_time;	/* initialize dynmgr_time */	

if (time(&que_time) == -1)
	{
	sprintf(log_buf, "Failed to get system time. errno=%d.", errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}
if (time(&appl_off_time) == -1)
	{
	sprintf(log_buf, "Failed to get system time. errno=%d.", errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}

for(;;)						/* the watchdog */
	{
	/* following routine check for all dead application and update info */
	(void) check_kill_app();

	/* This routine update pid fields from shared memory to array */
	(void) fill_vecs(tran_tabl_ptr, appl_pid);

	/* update the shared memory for application newly schedule or change */
	update_shmem();
	/* start application(s).  */
	(void) launch_applications(tran_proc_num, tran_tabl_ptr,
			appl_stat_arry, appl_pid);

	if (time(&curr_time) == -1) 		/* get the system time */
		{
		sprintf(log_buf, "Failed to get system time. errno=%d.", errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		}
	/* Message Queue cleanup for application being terminated */
	if((curr_time-que_time) >= MQUE_CLEANUP_TIME)
		{
		(void) clean_msgs_for_dead_appl();
		que_time = curr_time;
		/* removes the messages of the given type 'type' */
		type = 1;
		msg1.mesg_type = type;	/* message of dynamic manager type */
		memset(msg1.mesg_data, 0, sizeof(msg1.mesg_data));
		ret_code = mesg_recv(dyn_mqid, &msg1);
		if(ret_code > 0)		/* request found */
			{			
			sprintf(log_buf, "MESSAGE IN QUEUE type %d, data <%s>", 
					msg1.mesg_type, msg1.mesg_data);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			}
		}
	if((curr_time-appl_off_time) >= MAX_FIRE_LAPS_SEC)
		{
		for(j=0; j < tran_proc_num; j++)
			{
			if(count[j] > numOfTimesAppFired) 
				{
				(void)write_fld(tran_tabl_ptr, j, APPL_STATUS, STATUS_OFF);
				(void)read_fld(tran_tabl_ptr, j, APPL_NAME, off_appl_name);     
				sprintf(log_buf, "Application <%s> (%d) started %d times in %d seconds. Spawning too rapidly.",	off_appl_name, j, count[j], MAX_FIRE_LAPS_SEC);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 				check_and_send_snmp_trap(3009, log_buf, SNMP_Group_Id);
				/* Application stopped */
				}
			count[j] = 0; 
			}
		appl_off_time = curr_time;
		}
	/* after every hbeat_interval seconds, check application health */
	if((int)(curr_time-hbeat_time) >= hbeat_interval)
		{		
		/* Initialize the signal vector */
		(void)read_arry(tran_tabl_ptr, APPL_SIGNAL, tran_sig);
		(void)read_arry(tran_tabl_ptr, APPL_STATUS, tran_status);
		for(i=0; i<tran_proc_num; i++)
			{
			if(tran_sig[i] == 0)
				{
				if((tran_status[i] != STATUS_IDLE)&&(tran_status[i] != STATUS_OFF)&&(tran_status[i] != STATUS_CHNOFF))
					{	
					if(appl_pid[i] != 0)
						{
						//(void) kill((pid_t)appl_pid[i], SIGTERM);
						(void) kill((pid_t)appl_pid[i], SIGKILL);
						(void)read_fld(tran_tabl_ptr, i, APPL_RESOURCE, off_res_name);     
						(void)read_fld(tran_tabl_ptr, i, APPL_NAME, off_appl_name);
						last_api_name[0] = '\0';
						(void)read_fld(tran_tabl_ptr, i, APPL_API, last_api_name);
						sprintf(log_buf, ISP_EACTIVITY, off_appl_name, off_res_name, appl_pid[i], hbeat_interval, last_api_name);
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 						check_and_send_snmp_trap(3010, log_buf, SNMP_Group_Id);
						/* no activity for hang test */
						} /* pid != 0 */
					} /* status not idle and off */
				}
			} /* for all applications */
		/* reset sig */
		for(i=0; i<tran_proc_num; i++)
			tran_sig[i] = 0;

		hbeat_time = curr_time;

		/* update the signal vector into the shared memory */
		(void)write_arry(tran_tabl_ptr, APPL_SIGNAL, tran_sig);
		} /* hang_test */

	if (object == TEL)
		{
		/*after every resact interval seconds, check B-channel status */
		if((int)(curr_time-resact_time) >= RESACT_INTERVAL)
			{
			reevaluate_port_state();
			checkAlarmHandlerFile(); 
			resact_time = curr_time;
			}
		/*after every dynmgr interval secs, look for DynMgr.port file */
		if((int)(curr_time-dynmgr_time) >= DYNMGR_INTERVAL)
			{
			look_for_dynmgr_file();
			dynmgr_time = curr_time;
			}
		/* check for dynamic manager request */
		(void) process_dyn_mgr_request();
		if(Turnkey_License == 1)
			{
			checkValidTurnkeyApp();
			}
		}

	/* check for update configuration table request */
	database_hit = 0;
	if (check_update_table_request() == 0)	/* request for table updation */
		{
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, "Reloading system tables.");
		memset(report_mode, 0, sizeof(report_mode));
		ret_code = getLogparmValue(report_mode);
		if(ret_code == 0)
			changeLogMode(report_mode);
		if (load_tables(schedule_tabl, resource_tabl, appref_tabl, pgmref_tabl) != ISP_SUCCESS)
			{
			exit (0);  /* decision making exit */
			}
		if(object == TEL)
			{
			port_rc = loadResactTable(failureReason);
			if(port_rc != 0) 
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, failureReason);
			(void)read_arry(tran_tabl_ptr,APPL_STATUS,tran_status);
			for(i=0; i<tran_proc_num; i++)
				{
				if(tran_status[i] == STATUS_CHNOFF)
					{	/* port Off in shared memory */
					port_rc = portActive(i, &portState, failureReason);
					if(port_rc != 0) 
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, failureReason);
					if(portState == 1)
						{
						//sprintf(log_buf, " STATUS_INIT (1), port %d", i);
	//	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
						write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_INIT);
						}
					}
				}
			}
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, "Done reloading system tables.");
		database_hit = 1;
		} /* check_update_table_request */
	/* following sleep could cause problem for telecom dynamic manager */
	/*make no_sleep = 0 */
	no_sleep = 0;
	if (object != TEL)
		(void) sleep(NAP_TIME);		/* sleep time */
	else
		{
		for (sec_cnt = 0; sec_cnt < NAP_TIME; sec_cnt ++)
			{
			if(msgctl(dyn_mqid, IPC_STAT, &mesg_stat) == 0)
				{
				/* check dynamic manager request queue */
				if (mesg_stat.msg_qnum > 0)
					{
					/* request found */
					break;
					}
				else
					{
					(void)fill_vecs(tran_tabl_ptr,appl_pid);
					for(i=0; i< tran_proc_num; i++)
						{
						if(kill(appl_pid[i], 0) == -1)
							{
							if(errno == ESRCH)
								{ /*No process*/
								no_sleep = 1;
								break;
								}
							}
						}
					if(no_sleep == 1)
						break;
					/* no request */
					/* sleep(1); */
					util_sleep(0, 500);
					}
				} 
			else
				{
				util_sleep(0, 500);
				/*sleep(1); */
				}
			} /* for */
		}
	} /* watchdog */
} /* main */
/*------------------------------------------------------------------------------
 this routine reads the vectors from the shared memory 
------------------------------------------------------------------------------*/
int fill_vecs(prv_ptr, pid)
char	*prv_ptr;
int	pid[];
{
static	char	ModuleName[] = "fill_vecs";

(void)read_arry(prv_ptr, APPL_PID, pid);		/* read the proc_id s */
return (ISP_SUCCESS);
} /* fill_vecs */
/*------------------------------------------------------------------------------
 This routine launch the application based on the information in shared memory
 and scheduling table. if the value for the corresponding element is 0 
------------------------------------------------------------------------------*/
int launch_applications(proc_num, mem_ptr, stat_arry, pid)
int	proc_num;			/* # of processes */
char	*mem_ptr;			/* pointer to the shared mem */
int	stat_arry[];			/* process status array */
int	pid[];				/* proc_ids */
{
int	i, k, resource_found = 0, ret=0, t, dir_index=0;
char	*pvt_ptr, *ptr;		/* temp storage of shared memory  */
char	appl_name[256];		/* Name of the application */
char	dir_name[256];		/* Name of the directory */
char	program_name[256];	/* Name of the program */
char	reco_no[30];		/* record # in the shared memory */
char	host_name[20];		/* Host name as in shared memory */
char	field4[20];		/* field reserve for future  */
char	field5[20];		/* field reserve for future */
char	appl[100];		/* table name as in the shared memory  */
char	field6[25];		/* field reserve for future */
char	Emu_no[20];		/* emulator name as in shared memory  */
char	resource_id[30];	/* resource name in shared memory */
int     stat_str[MAX_PROCS];
char	isdn_flag[10];
char	state[10];
char	shm_index[20];
struct	schedule record;
static	char	ModuleName[] = "launch_applications";
time_t	start_time;
char	disconnect_res[20];
int	portState;
int	loop;
char	failureReason[256];

state[0] = isdn_flag[0] = shm_index[0] = '\0';
memset(&record, 0, sizeof(struct schedule));
/* set spaces to memory variable for fork  dynamic manager*/
if (object == TEL)
	{
	sprintf(record.acct_code, "%s", "               ");
	sprintf(record.destination, "%s", "          ");
	sprintf(record.origination, "%s", "          ");
	}

pvt_ptr = mem_ptr;		/* save the shared memory pointer */
(void)read_arry(tran_tabl_ptr, APPL_STATUS, stat_str);

for(i=0; i<proc_num; i++)
	{
	if (object == TEL)
		sprintf(record.destination, "%s", "          ");
	if(!stat_arry[i])
		{
		stat_arry[i] = 1;
				/* set the process status to 1 */
		if(pid[i])      /* Clear the messages if process gets killed */
			{
			if(pid[i] > 0)
				{
				if (kill(pid[i], 0) == -1)
					(void) remove_msgs(pid[i]);
				}
			else
				{
				mem_ptr += SHMEM_REC_LENGTH; /* next record*/
				continue;
				}
		}
		sscanf(mem_ptr, "%s%s%s%s%s%s%s%*d%*d%*d\n", host_name, Emu_no,
		 resource_id, field4, field5, field6, appl);
					/* read the shared memory */
		(void) strcpy(appl_name, appl);
		sprintf(reco_no, "%d", i);
				/* create the record # */
		if((strcmp(appl_name, "N/A") == 0) || (strcmp(appl_name, RESERVE_PORT) == 0) || (strcmp(appl_name, DCHAN) == 0))	/* application off */
			{
			(void)write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_OFF);
			mem_ptr += SHMEM_REC_LENGTH;	/* position the ptr */
			continue;
			}
		if((strcmp(appl_name, SKIP_PORT) == 0))	/* application off */
			{
sprintf(log_buf,"DEBUG: SKIP_PORT found, port=%d",i);
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			mem_ptr += SHMEM_REC_LENGTH;	/* position the ptr */
			continue;
			}
		if((object == TEL) && 
				(strcmp(resource[i].res_state,"DYN_MGR")==0) &&
				(strcmp(resource[i].static_dest,"ArcGDynMgr")==0))
			{
			mem_ptr += SHMEM_REC_LENGTH;	/* position the ptr */
			continue;
			}
		if(object == TEL && strcmp(resource[i].res_state,"DYN_MGR")==0)
			{
			if(dynmgr_pid[i] != 0)
				{
				if(kill(dynmgr_pid[i], 0) == -1)
					{
					if(strncmp(appl_name,"ASSIGNED:",9)==0)
						{
						stat_arry[i] = 0;
						/*restore to re-fire*/
						mem_ptr += SHMEM_REC_LENGTH;
						continue;
						}
					else
						;
					}
				else
					{
					stat_arry[i] = 0;/*restore to re-fire*/
					mem_ptr += SHMEM_REC_LENGTH;
/*
sprintf(log_buf,"DEBUG: Dynamic Manager (%d) running, slot %d",dynmgr_pid[i],i);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
*/
					continue;
					}
				}
			}
		if((object == TEL) && (strcmp(resource[i].res_state,"STATIC")==0) && (strcmp(resource[i].res_type,"ISDN")==0))
			{
			if(dynmgr_pid[i] != 0)
				{
				if(kill(dynmgr_pid[i], 0) == -1)
					;
				else
					{
					stat_arry[i] = 0;/*restore to re-fire*/
					mem_ptr += SHMEM_REC_LENGTH;
sprintf(log_buf,"DEBUG: Dynamic Manager(STATIC) (%d) running, slot %d",dynmgr_pid[i],i);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
					continue;
					}
				}
			sprintf(record.destination, "%s", resource[i].static_dest);
			}
		ret_code = access(appl_name, R_OK | X_OK);
		if(ret_code != 0)
			{
			/* make status off */
			(void)write_fld(tran_tabl_ptr,i,APPL_STATUS,STATUS_OFF);
			sprintf(log_buf, ISP_ESTART, appl_name, errno);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			mem_ptr += SHMEM_REC_LENGTH;	/* goto next record */
			continue;
			}
		resource_found = ISP_NOTFOUND;
		if(stat_str[i] != STATUS_OFF)	/* if status is not stop */
			{
			/* find resource parameters in resource table */
			for (k = 0; k < tot_resources; k++)
				{
				if(strcmp(resource[k].res_no, resource_id) == 0)
					{
					resource_found = ISP_FOUND;
					break;
					}
				} /* find resource */
			if (resource_found == ISP_FOUND)
				{
				if(object==TEL || object==TCP || object == SNA)
					{
					/* load application information */
					/* check_data_token for analog only */
					if (strcmp(resource[k].res_type, "ANALOG") == 0 || strcmp(resource[k].res_type, "LU2") == 0 || strcmp(resource[k].res_type, "TELNET") == 0 || strcmp(resource[k].res_type, "RS232") == 0 )
						{
						if (check_data_token(TOKEN1_APPL, resource[k].static_dest, "", &record) != ISP_SUCCESS)
							{
							/* goto next record */
							mem_ptr += SHMEM_REC_LENGTH;
							continue;
							}
						if (application_instance_manager(ISP_CHECK_MAX_INSTANCE, record.program, resource_id) != ISP_SUCCESS)
							{
							/* goto next record */
							mem_ptr += SHMEM_REC_LENGTH;
							continue;
							}
						}
					} /* for Telecom object */
				/* set resource type to fire application */
				(void)set_resource_type_flag(resource[k].res_type, isdn_flag);
				/* for resource state staic/dynamic */
				(void)set_resource_state_flag(resource[k].res_state, state);
				} /* resource found */
			else
				{
				printf("before exec : Can't find resource (%s) in resource table\n", resource_id);
				mem_ptr += SHMEM_REC_LENGTH;	/* position the ptr to next record */
				continue;
				}
			/* shared memory index */
			sprintf(shm_index, "%d", i);
			count[i] += 1;
			time(&start_time);
			t = start_time;
			program_name[0] = '\0';
			dir_name[0] = '\0';
			/* set directory and program name */
			if (strchr(appl_name, '/') == NULL)
				{
				sprintf(program_name, "%s", appl_name);
				sprintf(dir_name, "%s", ".");
				}
			else
				{
				/* parse program name and directory name */
				sprintf(dir_name, "%s", appl_name);
				dir_index = strlen(dir_name) -1;
				for(;dir_index>=0; dir_index--)
        				{
        				if (dir_name[dir_index] == '/')
                				{
                				dir_name[dir_index] = '\0';
                				break;
                				}
        				}
				ptr = (char *) strrchr(appl_name, '/');
				if (ptr)
        				ptr++;
				sprintf(program_name, "%s", ptr);
				}
			if (dir_name[0] == '/')
				{
				/* full path */
				sprintf(appl_path, "%s/%s", dir_name, program_name);
				}
			else
				{
				/* relative path */
				if (strcmp(dir_name, ".") == 0) /*current dir*/
					sprintf(appl_path, "%s/%s", exec_path, program_name);
				else
					sprintf(appl_path, "%s/%s/%s", exec_path, dir_name, program_name);
				}
			sprintf(disconnect_res, "%d", res_attach[atoi(resource_id)]);
			write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_INIT);
			if(Turnkey_License == 1)
				write_fld(tran_tabl_ptr, i, APPL_FIELD5, 1);
			if(object == TEL && strcmp(resource[k].res_state, "DYN_MGR") == 0)
				{
				portActive(i,&portState,failureReason);
				if(portState == 0)
					write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_CHNOFF);
#if 0
				for(loop = 0; loop < 20; loop++)
					{
					if(i >= alarmStatus[loop].startPort && i <= alarmStatus[loop].endPort)
						{
						if(strcmp(alarmStatus[loop].status,"OFF") == 0)
							{
							write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_CHNOFF);
							}
						break;
						}
					}
#endif
				}
			if((pid[i] = fork()) == 0)
				{
				/* load configuration parameter */
				/* change directory */
				if (chdir(dir_name) != 0)
					{
					sprintf(log_buf, "Failed to execute chdir system call to <%s>. errno=%d.", dir_name, errno);
					LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
					}
				switch (object)
				{
				case	TEL:
					/* Telecom Server application */
					ret = execl(appl_path, program_name, 
					"-P", program_name, 
					"-y", record.acct_code,
					"-p", resource_id, 
					"-D", record.destination,
					"-A", record.origination,
					"-c", isdn_flag,
					"-s", state,
					"-G", DefaultLang,
					"-R", rlt_flag,
/*
					"-z", diag_flag,
 */
					"-I", shm_index,
					(char *) 0);
					break;
				case	TCP:
					ret = execl(appl_path, program_name, 
					"-P", program_name, 
					"-y", record.acct_code,
					"-p", resource_id, 
					/* resource interface name */
					"-t", resource[k].res_type,
					/* host name */
					"-H", resource[k].res_usage,
					"-s", state,
					"-h", heartbeat_interval, 
					"-I", shm_index,
					(char *) 0);
					break;
				case	SNA:
					ret = execl(appl_path, program_name, 
					/* resource PU name */
					"-L", resource[k].res_qualifier,
					"-P", program_name, 
					"-y", record.acct_code,
					"-p", resource_id, 
					"-s", state,
					"-h", heartbeat_interval, 
					"-I", shm_index,
					/* "-z", diag_flag, */
					(char *) 0);
					break;
				case	WSS:
					break;
				default:
					/* will never happen */
					break;
				} /* switch */
				/* check if exec failed */
				if (ret == -1)
					{
					sprintf(log_buf, "execl(path=<%s>, directory=<%s>, program=<%s>) system call failed. errno=%d.", appl_name, dir_name, program_name, errno);
					LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 					check_and_send_snmp_trap(3038, log_buf, SNMP_Group_Id);
					}
				exit (0);
				sprintf(log_buf, ISP_ESTART, appl_name, errno);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				}
			if (pid[i] == -1)
				{
				sprintf(log_buf, "Failed to execute fork() system call. errno=%d.", errno);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 				check_and_send_snmp_trap(3041, log_buf, SNMP_Group_Id);
				
				} /* if fork failed */
			else
				{
				/* for dynamic manager update flag to idle */
				if (object == TEL && strcmp(resource[k].res_state, "DYN_MGR") == 0)
					{
/*
					portActive(i,&portState,failureReason);
					if(portState == 0)
						write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_CHNOFF);
*/
					res_status[atoi(resource_id)].status = FREE;
					res_status[atoi(resource_id)].pid = pid[i];
	/*				dynmgr_pid[k] = pid[i]; */
					}
				if(object == TEL)
					dynmgr_pid[k] = pid[i];
				/* update application start time and pid */
				(void)write_fld(tran_tabl_ptr, i, APPL_PID, pid[i]); 
				(void)write_fld(tran_tabl_ptr, i, APPL_START_TIME, t); 
				/* increase the application instance for this program */
				if((object == TEL) && (strcmp(resource[i].res_state,"STATIC")==0) && (strcmp(resource[i].res_type,"ISDN")==0))
					;
				else
					(void)application_instance_manager(ISP_ADD_INSTANCE, appl_name, resource_id);
				/* Log the message for application being started */
				sprintf(log_buf, ISP_APPINFO, appl, pid[i], resource_id);
				LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
				if (object == TEL)
					res_attach[atoi(resource_id)] =  RESOURCE_NOT_ATTACH;
				} /* else fork success */
			}
		else
			{
			stat_arry[i] = 0;
			}
		if (object == SNA)
			(void) sleep(2); 
		} /* stat_arry */
	mem_ptr += SHMEM_REC_LENGTH;	/* position the ptr to next record */
	} /* for */
mem_ptr = pvt_ptr;		/* restore the the shared memory pointer */

return (ISP_SUCCESS);
} /* launch_applications */
/*------------------------------------------------------------------------------
This routine creates the shared memory segment 
------------------------------------------------------------------------------*/
int SHMGET(key, size, flag)
key_t 	key;				/* key for the segment */
int	size;				/* size of the segment */
int	flag;				/* permisions for access */
{
int	id;			/* id for the shared memory */
static	char	ModuleName[] = "SHMGET";

if((id = shmget(key, size, flag|IPC_CREAT|IPC_EXCL)) < 0)
	{
	sprintf(log_buf, ISP_ESHMID, key, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 	check_and_send_snmp_trap(3005, log_buf, SNMP_Group_Id);
	return (-1);
	}
return(id);
} /* SHMGET */
/*------------------------------------------------------------------------------
this routine creates the message queue 
------------------------------------------------------------------------------*/
int MSGGET(key, flag)
long	key;				/* key for the message queue */
int	flag;				/* access permissions */
{
int	id;			/* message queue id */
static	char	ModuleName[] = "MSGGET";

if((id = msgget(key, flag|IPC_CREAT|IPC_EXCL)) < 0)
	{
	sprintf(log_buf, ISP_EMSGQID, key, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 	check_and_send_snmp_trap(3007, log_buf, SNMP_Group_Id);
	return (-1);
	}
return(id);
} /* MSGGET */
/*------------------------------------------------------------------------------
This routine creates the shared memory segments and Message Queues 
------------------------------------------------------------------------------*/
#define	SHMKEY_DYNMGR	((key_t)5008) /* DYNMGR shared memory segment */
int create_msgq_shmem(int obj)
{
key_t	shm_key;
long	que_no;
long	dyn_mgr_que=0L;
int	dynmgr_shmid;
static	char	ModuleName[] = "create_msgq_shmem";

sprintf(log_buf, ISP_EMSG, "Creating shared memory and message queue.");
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
/* set shared memory key and queue */
switch(obj)
	{
	case	TEL:
		shm_key = SHMKEY_TEL;
		dyn_mgr_que = TEL_DYN_MGR_MQUE;
		break;
	case	WSS:
		shm_key = SHMKEY_WSS;
		dyn_mgr_que = WSS_DYN_MGR_MQUE;
		break;
	case	SNA:
		shm_key = SHMKEY_SNA;
		break;
	case	TCP:
		shm_key = SHMKEY_TCP;
		break;
	default:
		sprintf(log_buf, ISP_EOBJ_NUM, obj);	
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
	} /* switch */

GV_shm_key = shm_key;
GV_dyn_mgr_que  = que_no;
/* create shared memory segment */
if((tran_shmid = SHMGET(shm_key, SIZE_SCHD_MEM, PERMS)) < 0)
	{
	return (ISP_FAIL);
	}
sprintf(log_buf, ISP_SHMINFO, (long)shm_key, shm_key);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

/* Create dynamic manager request Queue if set */
if (dyn_mgr_que != 0L)
	{
	if((dyn_mqid = MSGGET(dyn_mgr_que, PERMS)) < 0)
		{
		return (ISP_FAIL);
		}
	sprintf(log_buf, ISP_EMSGQINFO, dyn_mgr_que, dyn_mgr_que);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	} /* if set */
#ifdef DIALOGIC1
/* create dynamic manager shared memory segment */
if((dynmgr_shmid = SHMGET(SHMKEY_DYNMGR, SIZE_SCHD_MEM, PERMS)) < 0)
	{
	sprintf(log_buf, "Failed to create dynmgr shared memory. errno=%d.", 
								errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	
	return (ISP_FAIL);
	}
#endif 

return (ISP_SUCCESS);
} /* create_msgq_shmem */
/*------------------------------------------------------------------------------
 This routine removes unnecessary messages from the message Queue. 
------------------------------------------------------------------------------*/
int remove_msgs(type)
int	type;
{
Mesg	msg1;
Mesg2	msg2;
long	que_no;
static	char	ModuleName[] = "remove_msgs";
static	int	got_msgqid = 0;

if (object == TEL)
	{
	/* to cleanup leftover message of application on message queue */
	msg1.mesg_type = type;	/* message of dynamic manager type */
	msg1.mesg_data[0] = '\0';
	mesg_recv(dyn_mqid, &msg1);
	}
if(start_net_serv == 0)
	return(0);
else
	{
	if(got_msgqid == 0)
		{
		switch(object)
			{
			case	TEL:
				que_no  = TEL_RESP_MQUE;
				break;
			case	WSS:
				que_no  = WSS_RESP_MQUE;
				break;
			case	SNA:
				que_no  = SNA_REQS_MQUE;
				break;
			case	TCP:
				que_no  = TCP_REQS_MQUE;
				break;
			default:
				sprintf(log_buf, ISP_EOBJ_NUM, object);	
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				return (ISP_FAIL);
			} /* switch */
		/* get message id for the request/response queue */
		GV_que_no = que_no;
		resp_mqid = msgget(que_no, PERMS);
		got_msgqid = 1;
		}
	}
msg1.mesg_type = (long)type;	
			/* removes the messages of the given type 'type' */
msg2.mesg_type2 = (long)type;
(void) mesg_recv1(resp_mqid, &msg2);

return (ISP_SUCCESS);
} /* remove_msgs */	
/*------------------------------------------------------------------------------
 This routine reads the message from the message queue 
------------------------------------------------------------------------------*/
int mesg_recv1(id, mesqptr2)
int	id;
Mesg2   *mesqptr2;
{
static	char	ModuleName[]="mesg_recv1";
int	ret_code;

ret_code = msgrcv(id, mesqptr2, 512, mesqptr2->mesg_type2, 0|IPC_NOWAIT);
if(ret_code <= 0)
	{
	if(errno != ENOMSG)		/* no message of that type */
		{
		sprintf(log_buf, ISP_ERECV_MESG, GV_que_no, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return(-1);
		}
	}
return(ret_code);
} /* mesg_recv1 */
/*------------------------------------------------------------------------------
 This routine reads the message from the message queue 
------------------------------------------------------------------------------*/
int mesg_recv(id, mesqptr)
int	id;
Mesg	*mesqptr;
{
static	char	ModuleName[]="mesg_recv";
int	ret_code;

ret_code = msgrcv(id, mesqptr, MSIZE, mesqptr->mesg_type, 0|IPC_NOWAIT);
if(ret_code <= 0)
	{
	if(errno != ENOMSG)		/* no message of that type */
		{
		sprintf(log_buf, ISP_ERECV_MESG, GV_dyn_mgr_que, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 		check_and_send_snmp_trap(3017, log_buf, SNMP_Group_Id);
		return(-1);
		}
	}
return(ret_code);
} /* mesg_recv */
/*------------------------------------------------------------------------------
 This routine loads the shared memory into the memory 
------------------------------------------------------------------------------*/
int load_shmem_tabl(mem_id)
int	mem_id;
{
static	char	ModuleName[]="load_shmem_tabl";
int	res_found=ISP_NOTFOUND;
int	slot_no=0;
char	*pvt_ptr;		/* pointer to the shared memory */
char	buf[BUFSIZE];
char	*tmp_ptr;
char	resource_no[30];
char	file_name[MAX_PROGRAM];
char	appl_grp[MAX_APPLICATION];

pvt_ptr = shmat(mem_id, 0, 0); 	/* attach the shared memory segment */
tmp_ptr = pvt_ptr;
if(pvt_ptr == (char *) (-1))
	{
	sprintf(log_buf, ISP_ESHM_AT, GV_shm_key, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 	check_and_send_snmp_trap(3003, log_buf, SNMP_Group_Id);
	return (ISP_FAIL);
	}
/* load resource into shadred memory slot */
for (slot_no=0; slot_no<MAX_SLOT && slot_no < tot_resources; slot_no++)
	{ 
	buf[0] = '\0';
	file_name[0] = '\0';
	sprintf(resource_no, "%s", resource[slot_no].res_no);
	/* for ISDN dynamic application fire dynamic manager */
	switch(object)
		{
		case	TEL:
			if (strcmp(resource[slot_no].res_usage, RESERVE_PORT) == 0 )
				{
				sprintf(file_name, "%s", RESERVE_PORT);
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
				break;
				} /* if ISDN & DYN_MGR */
			if (strcmp(resource[slot_no].res_usage, SKIP_PORT) == 0 )
				{
sprintf(log_buf,"DEBUG: SKIP_PORT found, port=%d",slot_no);
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				sprintf(file_name, "%s", SKIP_PORT);
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
				break;
				} /* if ISDN & DYN_MGR */
			if (strcmp(resource[slot_no].res_type, "ISDN") == 0 && strcmp(resource[slot_no].res_state, "DYN_MGR") == 0)
				{
				sprintf(file_name, "%s", resource[slot_no].static_dest);
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
				} /* if ISDN & DYN_MGR */
			else
				{
				if (find_application(SCHEDULER, slot_no, resource[slot_no].static_dest, "", file_name, appl_grp) != ISP_SUCCESS)
					{
					sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", "N/A", "6", "0", "0");
					}
				else
					{
					if (strcmp(resource[slot_no].res_type, "ISDN") == 0 && strcmp(resource[slot_no].res_state, "STATIC") == 0)
						{
						sprintf(file_name, "%s", resource[slot_no].res_usage);
						sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
						}
					else
						sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
					}
				} /* if not ISDN */
			break;

		case	TCP:
			if (find_application(SCHEDULER, slot_no, resource[slot_no].static_dest, "", file_name, appl_grp) != ISP_SUCCESS)
				{
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", "N/A", "6", "0", "0");
				}
			else
				{
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
				}
			break;

		case	SNA:
			if (find_application(SCHEDULER, slot_no, resource[slot_no].static_dest, "", file_name, appl_grp) != ISP_SUCCESS)
				{
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", "N/A", "6", "0", "0");
				}
			else
				{
				sprintf(buf, SHM_FORMAT, "Reserve", "0", resource_no, "field4", "0", "0000000000", file_name, "0", "0", "0");
				}
			break;
		} /* switch */
	/*
	sprintf(log_buf, "slot no = %d >%s<", slot_no, buf);
	LogMsg(ModuleName, ISP_DEBUG_SHMEM, log_buf);
	*/
	/* fill the record into slot */
	(void) strncpy(pvt_ptr, buf, strlen(buf));
	pvt_ptr += strlen(buf);
	} /* for all slot */

ret_code = shmdt(tmp_ptr);		/* detach the shared memory segment */
if(ret_code == -1)
	{
	sprintf(log_buf, ISP_ESHM_DT, GV_shm_key, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
return (ISP_SUCCESS);
} /* load_shmem_tabl */
/*------------------------------------------------------------------------------
 this routine removes the shared memory & message queues 
------------------------------------------------------------------------------*/
int remove_msgqs(int obj)
{
key_t	shm_key;
long	que_no;
long	dyn_mgr_que=0L;
int	dynmgr_shmid;
static	char	ModuleName[] = "remove_msgqs";

/* set shared memory key and queue */
switch(obj)
	{
	case	TEL:
		shm_key = SHMKEY_TEL;
		dyn_mgr_que = TEL_DYN_MGR_MQUE;
		break;
	case	WSS:
		shm_key = SHMKEY_WSS;
		dyn_mgr_que = WSS_DYN_MGR_MQUE;
		break;
	case	SNA:
		shm_key = SHMKEY_SNA;
		break;
	case	TCP:
		shm_key = SHMKEY_TCP;
		break;
	default:
		sprintf(log_buf, ISP_EOBJ_NUM, obj);	
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
	} /* switch */

GV_shm_key = shm_key;
GV_dyn_mgr_que  = que_no;

/* get message id for the dynamic manager queue */
if (dyn_mgr_que != 0L)
	{
	dyn_mqid = msgget(dyn_mgr_que, PERMS);
	ret_code = msgctl(dyn_mqid, IPC_RMID, 0);
	if((ret_code < 0) && (errno != EINVAL))
		{
		sprintf(log_buf, ISP_EMSGQ_RM, dyn_mgr_que, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
		}
	} /* if dynamic manager */

/* remove shared memory  -  get shared memory segments id */
tran_shmid = shmget(shm_key, SIZE_SCHD_MEM, PERMS);
ret_code = shmctl(tran_shmid, IPC_RMID, 0);
if((ret_code < 0) && (errno != EINVAL))
	{
	sprintf(log_buf, ISP_ESHM_RM, GV_shm_key, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}

#ifdef DIALOGIC1
/* remove shared memory  -  get shared memory segments id */
dynmgr_shmid = shmget(SHMKEY_DYNMGR, SIZE_SCHD_MEM, PERMS);
ret_code = shmctl(dynmgr_shmid, IPC_RMID, 0);
if((ret_code < 0) && (errno != EINVAL))
	{
	sprintf(log_buf, "Failed to remove dynmgr shared memory. errno=%d.", 
								errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
#endif 

return (ISP_SUCCESS);
} /*remove_msgqs */
/*--------------------------------------------------------------------------
Check if responsibility is already running.
---------------------------------------------------------------------------*/
static	char	ps[] = "ps -ef";   

int check_responsibility()
{
static	char	ModuleName[] = "check_responsibility";
FILE	*fin;			/* file pointer for the ps pipe */
int	i;
char	buf[BUFSIZE];

if((fin = popen(ps, "r")) == NULL)
	{		/* open the process table */
	sprintf(log_buf, ISP_EOPEN_PIPE, "Failed to verify that Responsibility is running.", ps, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	exit(0);
	}

(void) fgets(buf, sizeof buf, fin); 	/* strip of the header */
				/* get the responsibility s proc_id */
i = 0;
while (fgets(buf, sizeof buf, fin) != NULL)
	{
	if(strstr(buf, resp_name) != NULL)
		{
		i = i + 1;
		if(i >= 2)
			{
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, "Responsibility is already running.");
			exit(0);
			}
		}
	}
(void) pclose(fin);

return(ISP_SUCCESS);
} /* check_responsibility */

/*------------------------------------
Check if all configuration file exists.
--------------------------------------*/
int check_configuration_tables(obj)
int	obj;
{
static	char	ModuleName[] = "check_configuration_tables";
register	int	i=0;
int	tot_config_table = 0;
char	file_path[1024];

LogMsg(ModuleName, ISP_DEBUG_DETAIL, "check_configuration_table(): Checking configuration tables ...");
switch (obj)
	{
	case	TEL:
		tot_config_table = tel_tot_tables;
		break;
	case	SNA:
		tot_config_table = sna_tot_tables;
		break;
	case	TCP:
		tot_config_table = tcp_tot_tables;
		break;
	case	WSS:
		tot_config_table = wss_tot_tables;
		break;
	default :
		sprintf(log_buf, ISP_EOBJ_NUM, obj);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
	} /* switch */

for (i=0; i < tot_config_table; i++)
	{
	if (obj == TEL)
		sprintf(file_path, "%s/%s", table_path, tel_config_file[i]);
	else if (obj == SNA)
		sprintf(file_path, "%s/%s", table_path, sna_config_file[i]);
	else if (obj == TCP)
		sprintf(file_path, "%s/%s", table_path, tcp_config_file[i]);
	else if (obj == WSS)
		sprintf(file_path, "%s/%s", table_path, wss_config_file[i]);
	else
		{
		sprintf(log_buf, ISP_EOBJ_NUM, obj);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
		}
	sprintf(log_buf, ISP_CHKFILE, file_path);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	/* check if file exists */	
	ret_code = access(file_path, R_OK);
	if(ret_code < 0)
		{
		sprintf(log_buf, ISP_EOPEN_FILE, file_path, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
		}
	} /* for all files */
return (ISP_SUCCESS);
} /* check_configuration_tables */
/*----------------------------------------------------------------------------
int chek_environment()
---------------------------------------------------------------------------*/
int check_environment(int obj)
{
static	char	ModuleName[] = "check_environment";
char 	*speech_file_var;
char	*home;

LogMsg(ModuleName, ISP_DEBUG_DETAIL, "check_environment(): Checking Environment");
/* set HOME path */
if ((home = getenv("HOME")) == NULL)
	{
	sprintf(log_buf, ISP_EENV, "HOME");
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 	check_and_send_snmp_trap(3001, log_buf, SNMP_Group_Id);
	return (ISP_FAIL);
	}
sprintf(isp_home, "%s", home);

/* set ISPBASE path */
if ((base_path=(char *)getenv("ISPBASE")) == NULL)
	{
	sprintf(log_buf, ISP_EENV, "ISPBASE");
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 	check_and_send_snmp_trap(3001, log_buf, SNMP_Group_Id);
	return (ISP_FAIL);
	}
sprintf(isp_base, "%s", base_path);

switch (obj)
	{
	/* check environment for telecom server */
	case	TEL:
		/* check for OBJDB */
		speech_file_var=(char *)getenv("OBJDB");   
		if(!speech_file_var)
			{
			sprintf(log_buf, ISP_EENV, "OBJDB");
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 			check_and_send_snmp_trap(3001, log_buf, SNMP_Group_Id);
			return (ISP_FAIL);
			}
		return (ISP_SUCCESS);
	case	SNA:
		/* check access running for background */
		break;
	case	TCP:
		/* nothing */
		break;
	case	WSS:
		/* nothing */
		break;
	default :
		sprintf(log_buf, ISP_EOBJ_NUM, obj);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
	} /* switch */		
return (ISP_SUCCESS);
} /* check_environment */
/*----------------------------------------------------------------------------
int set_object_path()
---------------------------------------------------------------------------*/
int set_object_path(int obj)
{
static	char	ModuleName[] = "set_object_path";
char	server_dir[256];
struct	utsname	sys_info;
struct	rlimit 	limits;

sprintf(ModuleName, "%s", "set_object_path");
/* get machine name on which object is running */
(void)uname(&sys_info);
sprintf(log_buf, "Machine Name = %s", sys_info.nodename);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, "Setting directory path structure for object");
/* set default variables */
sprintf(heartbeat_interval, "%s", "60");	/* one minute */
sprintf(DefaultLang, "%s", "AMENG");
sprintf(AccessMode, "%s", "FORE");
sprintf(NetworkStatus, "%s", "OFF");
sprintf(diag_flag, "%s", "0");

sprintf(object_machine_name, "%s", sys_info.nodename);

switch (obj)
	{
	case	TEL:
		sprintf(server_dir, "%s", TELECOM_DIR);
		break;
	case	SNA:
		sprintf(server_dir, "%s", SNA_DIR);
		break;
	case	TCP:
		sprintf(server_dir, "%s", TCP_DIR);
		break;
	case	WSS:
		sprintf(server_dir, "%s", WSS_DIR);
		break;
	default :
		sprintf(log_buf, ISP_EOBJ_NUM, obj);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
	} /* switch */
sprintf(table_path, "%s/%s/%s", isp_base, server_dir, TABLE_DIR);
sprintf(exec_path, "%s/%s/%s", isp_base, server_dir, EXEC_DIR);
sprintf(global_exec_path, "%s/%s/%s", isp_base, GLOBAL_DIR, EXEC_DIR);
sprintf(lock_path, "%s/%s/%s", isp_base, server_dir, LOCK_DIR);

/* set configuration table files path */
sprintf(schedule_tabl, "%s/%s", table_path, "schedule");
sprintf(resource_tabl, "%s/%s", table_path, "ResourceDefTab");
sprintf(appref_tabl, "%s/%s", table_path, "appref");
sprintf(pgmref_tabl, "%s/%s", table_path, "pgmreference");

LogMsg(ModuleName, ISP_DEBUG_DETAIL, exec_path);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, table_path);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, lock_path);
/* set resource limit for number of file open */
(void)getrlimit(RLIMIT_NOFILE, &limits);
limits.rlim_cur = limits.rlim_max;
(void)setrlimit(RLIMIT_NOFILE, &limits);
/* set session leader as responsibility */
setsid(); 
return (ISP_SUCCESS);
} /* set_object_path */
/*------------------------------------------------------------------------
This routine initializes the dead_application and dead_tran_stat array, dynamic
manager array.
-------------------------------------------------------------------------*/
void init_array()
{
int i;

for(i = 0; i < MAX_PROCS; i++)
	{
	res_status[i].status = NOT_FREE; /* initialize all resource not free */
	res_status[i].pid = 0; /* initialize all resource pid */
	res_attach[i] = RESOURCE_NOT_ATTACH;
	}
for(i = 0; i < MAX_DEAD_PROCS; i++)
	{
	dead_application[i] = -1;   	/* initialize the array element by -1 */
   	dead_appl_stat[i] = 0;    	/* initialize the status by 0 */
	}
return;
} 
/*-------------------------------------------------------------------------
This routine checks for the dead application and removes the message.
-------------------------------------------------------------------------*/
int clean_msgs_for_dead_appl()
{
int	i;

for(i=0; i< MAX_DEAD_PROCS; i++)
	{
	if(dead_application[i] != -1)
		{   /* if the dead proc_id exists then remove
                                      it from message response queue */
		if(dead_application[i] > 0)
			{
			if(kill(dead_application[i], 0) == -1)
				{
				if(errno == ESRCH)
					(void) remove_msgs(dead_application[i]);
				}
			}
		dead_appl_stat[i] += 1;	/* update status of appli. proc_id */
		}
	if(dead_appl_stat[i] >= 2)
		{     /*  message deleted - confirmation - reset flag */
		dead_application[i] = -1;         /* initialize the array */
		dead_appl_stat[i] = 0;          /* initialize the status */
		}
	}

return (ISP_SUCCESS);
} /* clean_msgs_for_dead_appl */
/*---------------------------------------------------------------------------
check the request (max request = MAX_REQUEST_PROCESS) on dynamic manager 
request queue and process the request(s) if any. 
----------------------------------------------------------------------------*/
int process_dyn_mgr_request()
{
static	char	ModuleName[]="process_dyn_mgr_request";
register	int	i, m;
int	type = DYNAMIC_MANAGER; 
int	found_application = ISP_NOTFOUND;
int	ret_code, dyn_mgr_pid;
char	application[MAX_PROGRAM];
char	acct_name[MAX_APPLICATION];
Mesg	mesg1;
char	port[30], token1[50], token2[50];
int	request = 0;
char	res_str[30];
int	free_port, port_type;
char	assign_name[15], name_str[15], field_name[15];
char	*ptr, *ptr1;
int	found_pid;
char	program_name[15];
char	field[100];

memset(application, 0, sizeof(application));
memset(acct_name, 0, sizeof(acct_name));
for (i=0; i<= MAX_REQUEST_PROCESS; i++)
	{
	mesg1.mesg_type = type;		/* message of dynamic manager type */
	mesg1.mesg_data[0] = '\0';
	ret_code = mesg_recv(dyn_mqid, &mesg1);
	if(ret_code > 0)		/* request found */
		{			
		found_application = ISP_NOTFOUND;
		sprintf(log_buf, ISP_MSGDATA, mesg1.mesg_type, mesg1.mesg_data);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		if (mesg1.mesg_type == DYNAMIC_MANAGER)
			{
			sprintf(log_buf, "Received Message from dynamic manager = %s", mesg1.mesg_data);
			LogMsg("mesg_recv", ISP_DEBUG_DETAIL, log_buf);
			token1[0] = '\0';
			token2[0] = '\0';
			port[0]   = '\0';
			dyn_mgr_pid = -1;
			utlGetField(mesg1.mesg_data, 1, field);
			sscanf(field, "%d", &request);
			utlGetField(mesg1.mesg_data, 2, field);
			sscanf(field, "%d", &dyn_mgr_pid);
			utlGetField(mesg1.mesg_data, 3, field);
			sscanf(field, "%s", port);
			utlGetField(mesg1.mesg_data, 4, field);
			sscanf(field, "%s", token1);
			utlGetField(mesg1.mesg_data, 5, field);
			sscanf(field, "%s", token2);
			/*
			sscanf(mesg1.mesg_data, "%d %d %s %s %s", &request, &dyn_mgr_pid, port, token1, token2);
			*/
			memset(application, 0, sizeof(application));
	
			/* check input parameters */
			/* to fire any application with null token */
			if (atoi(port) < 0)
				{
				sprintf(log_buf, "Invalid port number (%d) received from dynamic manager.", atoi(port));
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				found_application = ISP_NOTFOUND;
				}
			else
				{
				/* make dynamic manager port not free */
				switch(request)
					{
					case	REQUEST_APPLICATION:
					case    REQUEST_OVERLAY:
						if(request == REQUEST_OVERLAY)
							{
							(void)read_fld(tran_tabl_ptr, atoi(port), APPL_NAME, program_name);
							(void)application_instance_manager(ISP_DELETE_INSTANCE, program_name, port);
							}
						res_status[atoi(port)].status = NOT_FREE;
						res_status[atoi(port)].pid = dyn_mgr_pid;
						/* use the token 1 and token2 to find application */
						/* in case dynamic manager resource index = 0 WHY? MB 10/14/99 */
						if (find_application(DYNAMIC_MANAGER, atoi(port), token1, token2, application, acct_name) == ISP_SUCCESS)
							{
							found_application = ISP_FOUND;
							}
						else
							{
							found_application = ISP_NOTFOUND;
							}
						break;
					case	RSM_REQUEST_PORT:
						if(res_status[atoi(port)].status == FREE)
							{
							res_status[atoi(port)].status = NOT_FREE;
							res_status[atoi(port)].pid = dyn_mgr_pid;
							m = atoi(port);
							write_fld(tran_tabl_ptr,m,APPL_PID,dyn_mgr_pid); 
							write_fld(tran_tabl_ptr,m,APPL_STATUS,STATUS_BUSY); 
							write_fld(tran_tabl_ptr, m, APPL_SIGNAL, 1);
							sprintf(assign_name, "ASSIGNED:%s", "RSM");
							ptr = tran_tabl_ptr;
							ptr += (m*SHMEM_REC_LENGTH);
									/* position the pointer to the field */
							ptr += vec[APPL_NAME-1];	/* application start index */
							ptr1 = ptr;
							(void) memset(ptr1, ' ', MAX_APPL_NAME);
							ptr +=(MAX_APPL_NAME - strlen(assign_name));
							memcpy(ptr,assign_name,strlen(assign_name));
							sprintf(log_buf,"Assigned name <%s>.", assign_name);
							LogMsg(ModuleName,ISP_DEBUG_DETAIL,log_buf);
							found_application = 0;
							}
						else
							{
							found_application = 1;
							}
						sprintf(acct_name,"%s","NONE");
						sprintf(application, "%d", atoi(port));
						inform_dyn_mgr(request, found_application, application, acct_name, dyn_mgr_pid);
						continue;
						break;
					case	REQUEST_PORT:
						sprintf(acct_name,"%s","NONE");
						get_free_port(atoi(port),&port_type,&free_port, token1);
						/* free port reserve/dynamic */
						if (free_port >= 0)
							{
							res_attach[atoi(port)] = free_port;
		/* for reserve port, set status and assign pid */
							sprintf(acct_name, "%s", resource[free_port].static_dest);
							res_status[free_port].status = NOT_FREE;
							if(port_type == RESERVE)
								res_status[free_port].pid = dyn_mgr_pid;
							found_application = ISP_FOUND;
						sprintf(application, "%d", free_port);
						for(m=0; m < tot_resources; m++)
							{
							(void)read_fld(tran_tabl_ptr, m, APPL_RESOURCE, res_str);     
						/* update pid for application */
						/* by requester app pid */
							if (atoi(res_str) == free_port)
								{
								(void)write_fld(tran_tabl_ptr, m, APPL_PID, dyn_mgr_pid); 
								(void)write_fld(tran_tabl_ptr, m, APPL_STATUS, STATUS_BUSY); 
								(void)write_fld(tran_tabl_ptr, m, APPL_SIGNAL, 1);

								sprintf(assign_name, "ASSIGNED:%s", port);
								ptr = tran_tabl_ptr;
								ptr += (m*SHMEM_REC_LENGTH);
								/* position the pointer to the field */
								ptr += vec[APPL_NAME-1];	/* application start index */
								ptr1 = ptr;
								(void) memset(ptr1, ' ', MAX_APPL_NAME);
								ptr += (MAX_APPL_NAME - strlen(assign_name));
								(void) memcpy(ptr, assign_name, strlen(assign_name));
								sprintf(log_buf,"Assigned name <%s>. port %s.", assign_name, port);
								LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

								break;
								}
							
							} /* for */
							} /* if free port */
						else
							{
							found_application = ISP_NOTFOUND;
							sprintf(application, "%s", "-1");
							}
						/*
						sprintf(log_buf, "Available Port = %s, application pid = %d",  application, dyn_mgr_pid);
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
						*/
						/* give some time to application to de-register */
						break;
					case	RSM_RELEASE_PORT:
						sprintf(assign_name, "ASSIGNED:%s", "RSM"); 
						(void)read_fld(tran_tabl_ptr, atoi(port), APPL_NAME, name_str);
						if(strcmp(name_str, assign_name) == 0)
							{
							res_status[atoi(port)].status = FREE;
							res_status[atoi(port)].pid = 0;
							sprintf(log_buf, "DEBUG : Resource %s has been freed, <%s>", port, mesg1.mesg_data);
							LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
							read_fld(tran_tabl_ptr,atoi(port),APPL_RESOURCE,res_str); 
							if (atoi(res_str) == atoi(port))
								{
								write_fld(tran_tabl_ptr,atoi(port),APPL_STATUS,STATUS_KILL);
								write_fld(tran_tabl_ptr,atoi(port),APPL_API,0); 
								write_fld(tran_tabl_ptr,atoi(port),APPL_PID,0); 
					/*		appl_stat_arry[atoi(port)] = 0;	/* update the field to indicate */
								sprintf(field_name, "%s", RESERVE_PORT);
								ptr = tran_tabl_ptr;
								ptr += (atoi(port)*SHMEM_REC_LENGTH);
									/* position the pointer to the field */
								ptr += vec[APPL_NAME-1];	/* application start index */
								ptr1 = ptr;
								(void) memset(ptr1, ' ', MAX_APPL_NAME);
								ptr += (MAX_APPL_NAME - strlen(field_name));
								memcpy(ptr, field_name, strlen(field_name));
								write_fld(tran_tabl_ptr,atoi(port),APPL_PID,0); 
								sprintf(log_buf, "DEBUG:marked RESERVE Port %s", port);
								LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
								}
							}
						continue;
						break;
					case	RELEASE_PORT:
						found_pid = 0;
						for(m=0; m < tot_resources; m++)
							{
							(void)read_fld(tran_tabl_ptr, m, APPL_PID, res_str);     
							if(atoi(res_str) == dyn_mgr_pid)
								{
								if(m != atoi(port))
									{
									found_pid = 1;
									break;
									}
								}
							}	
						if(found_pid == 0)
							continue;
						sprintf(assign_name, "ASSIGNED:%d", m); 
						(void)read_fld(tran_tabl_ptr, atoi(port), APPL_NAME, name_str);
				/* Next two lines will work if respcom.c is modified to send port of dyn_mgr_pid as token1 */
						if(strcmp(name_str, assign_name) != 0)
							{
							sprintf(log_buf,"REL Port<%s><%s> didn't match", name_str, assign_name);
							LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
							continue;
							}
						if (res_status[atoi(port)].pid > 0 && res_status[atoi(port)].status == NOT_FREE)	/* allocated */
							{
							res_status[atoi(port)].status = FREE;
							res_status[atoi(port)].pid = 0;
							sprintf(log_buf, "DEBUG : Resource %s has been freed, <%s>", port, mesg1.mesg_data);
							LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
						/* mahesh added for loop 073196 */
						/* set application pid to 0 */
							for(m=0; m < tot_resources; m++)
								{
								(void)read_fld(tran_tabl_ptr, m, APPL_RESOURCE, res_str);     
								if (atoi(res_str) == atoi(port))
									{
									(void)write_fld(tran_tabl_ptr, m, APPL_STATUS, STATUS_KILL);
									(void)write_fld(tran_tabl_ptr, m, APPL_API, 0); 
									(void)write_fld(tran_tabl_ptr, m, APPL_PID, 0); 
									appl_stat_arry[m] = 0;	/* update the field to indicate */
									/* MB added 1/2/97 */
									if(strcmp(resource[atoi(port)].res_usage, RESERVE_PORT) == 0)
										{
										sprintf(field_name, "%s", RESERVE_PORT);
										ptr = tran_tabl_ptr;
										ptr += (atoi(port)*SHMEM_REC_LENGTH);
												/* position the pointer to the field */
										ptr += vec[APPL_NAME-1];	/* application start index */
										ptr1 = ptr;
										(void) memset(ptr1, ' ', MAX_APPL_NAME);
										ptr += (MAX_APPL_NAME - strlen(field_name));
										(void) memcpy(ptr, field_name, strlen(field_name));
										(void)write_fld(tran_tabl_ptr, atoi(port), APPL_PID, 0); 
										sprintf(log_buf, "DEBUG : marked RESERVE Port %s", port);
										LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
										}
									break;
									}
								} /* for */
							}
						else
							{
							sprintf(log_buf, "DEBUG : Resource %s is not busy, <%s>", port, mesg1.mesg_data);
							LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
							}
						continue;
						
					default:
						memset(application, 0, sizeof(application));
						sprintf(log_buf, ISP_ECMD, "dynamic manager message queue command",  request);
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
						continue;
					} /* switch */
				} /* else */
			if (found_application == ISP_FOUND && request == REQUEST_APPLICATION)
				{
				/* check maxium instances */
				if (application_instance_manager(ISP_CHECK_MAX_INSTANCE, application, port) != ISP_SUCCESS)
					{
					sprintf(log_buf, "application instance manager failed for %s, on port %s", application, port);
					LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
					found_application = ISP_NOTFOUND;
					}
				}
			/* notify result to application */
			ret_code = inform_dyn_mgr(request, found_application, application, acct_name, dyn_mgr_pid);
			if(ret_code == ISP_SUCCESS)
				{
				if(atoi(port) >= 0)
					{
					if(found_application==ISP_FOUND && (request==REQUEST_APPLICATION || request == REQUEST_OVERLAY))
						update_dyn_mgr_appl(port,dyn_mgr_pid,application,token1);
					}
				}
			}
		else
			{
			sprintf(log_buf, ISP_ECMD, "dynamic manager message queue",  (int)mesg1.mesg_type);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			continue;
			}
		}
	else
		{
		return (ISP_SUCCESS);		/* no request */
		}
	} /* for */
return(ISP_SUCCESS);
} /* process_dyn_mgr_request */
/*-------------------------------------------------------------------
load_tables(): This Routine load all the tables into memory.
--------------------------------------------------------------------*/
int	load_tables(char *schedule_file, char *resource_file, char *appref_file, char *pgmref_file)
{
static	char	ModuleName[]="load_tables"; 
static	int	first_time = 1;

/* Load server specific parameter configuration table */
load_parameter_configuration();
/* resource table can't be reload dynamically */
if (first_time == 1)
	{
	if (load_resource_table(resource_file) != ISP_SUCCESS)
		{
		return (ISP_FAIL);
		}
	first_time = 0;
	}
if (load_appref_table(appref_file) != ISP_SUCCESS)
	{
	return (ISP_FAIL);
	}
if (load_pgmref_table(pgmref_file) != ISP_SUCCESS)
	{
	return (ISP_FAIL);
	}
if (load_schedule_table(schedule_file) != ISP_SUCCESS)
	{
	return (ISP_FAIL);
	}
return (ISP_SUCCESS);
} /* load_tables */
/*-------------------------------------------------------------------
load_resource_table(): This Routine load resource table into memory.
--------------------------------------------------------------------*/
int	load_resource_table(char *resource_file)
{
static	char	ModuleName[]="load_resource_table";
FILE	*fp;
char	record[1024];
char	field[1024];
int	field_no = 0;
int	load_entry = 0;			/* decide whether to load entry */
int	skip_resources = 0;			/* See if there are skipped resources */

sprintf(log_buf, "load_resource_table(): Loading %s table", resource_file);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

if ((fp=fopen(resource_file, "r")) == NULL)
	{
	sprintf(log_buf, ISP_EOPEN_FILE, resource_file, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
while (fgets(record, sizeof(record), fp) != NULL)
	{
	load_entry = 1;			/* load the entry */
	for (field_no = 1; field_no <= MAX_RESOURCE_FIELD; field_no ++)
		{
		field[0] = '\0';
		if (get_field(record, field_no, field) < 0)
			{
			sprintf(log_buf, ISP_EFIELD, resource_file, field_no, tot_resources, record);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			load_entry = 0;		/* don't load entry */
			/* return (ISP_FAIL); */
			}
		if (load_entry == 0)		/* skip record for errors */
			break;
		switch(field_no)
			{
			case 	RESOURCE_NO:			/* port no */
				sprintf(resource[tot_resources].res_no, "%s", field);
				if ((int)strlen(resource[tot_resources].res_no) > fld_siz[APPL_RESOURCE-1])
					{
					sprintf(log_buf, "Ignoring entry ResourceDefTab <%s>, Resource name %s is > maximum resource length %d", record, field, fld_siz[APPL_RESOURCE-1]);
					LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
					continue;
					}
				break;
			case 	RESOURCE_TYPE:
				sprintf(resource[tot_resources].res_type, "%s", field);
				break;
			case 	RESOURCE_STATE:
				sprintf(resource[tot_resources].res_state, "%s", field);
				break;
			case 	RESOURCE_USAGE:
				sprintf(resource[tot_resources].res_usage, "%s", field);
				break;
			case	STATIC_DEST:
				sprintf(resource[tot_resources].static_dest, "%s", field);
				break;
			default :
				sprintf(log_buf, "File = %s, Field %d is invalid field number", resource_file, field_no);
				sprintf(log_buf, ISP_EMSG, log_buf);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				break;
			} /*switch */
		} /* for */
	if (load_entry == 0)
		continue;		/* skip entry */
	/* for sna object read PU name (resource qualifier) 
	   from resource file */
	if (object == SNA)
		{
		resource[tot_resources].res_qualifier[0] = '\0';
		(void) find_pu_name(resource[tot_resources].res_no, resource[tot_resources].res_qualifier);
		}
#ifdef DEBUG_TABLES
	sprintf(log_buf, "Resource no = %s", resource[tot_resources].res_no);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	if (object == SNA)
		{
		sprintf(log_buf, "Resource qualifier = %s", resource[tot_resources].res_qualifier);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		}
	sprintf(log_buf, "Resource type = %s", resource[tot_resources].res_type);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "Resource state = %s", resource[tot_resources].res_state);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "Resource usage = %s", resource[tot_resources].res_usage);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "Resource static destination = %s", resource[tot_resources].static_dest);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "%s", "*******************  next resource ***************");
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
#endif
	/* for reserve resource make resource status free */
	if ( strcmp(resource[tot_resources].res_usage, RESERVE_PORT) == 0)
		res_status[atoi(resource[tot_resources].res_no)].status = FREE;
	if ( strcmp(resource[tot_resources].res_usage, SKIP_PORT) == 0)
		{
		res_status[atoi(resource[tot_resources].res_no)].status = NOT_FREE;
		skip_resources = skip_resources + 1;
		}
	tot_resources ++;
	} /* while end of file */

(void) fclose(fp);

sprintf(log_buf,"Total entries loaded from resource table = %d.",tot_resources);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Skip resources from resource table = %d.", skip_resources);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

/* Adjust ports for number licensed */
if ((tot_resources - skip_resources) > Licensed_Resources)
	{
	sprintf(log_buf,"Only %d resources of %d defined are licensed. Using %d.", Licensed_Resources, tot_resources, Licensed_Resources);
		tot_resources = Licensed_Resources;
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}
return (ISP_SUCCESS);
} /* load_resource_table */
/*-------------------------------------------------------------------
load_schedule_table(): This Routine load scheduling table into memory.
--------------------------------------------------------------------*/
int	load_schedule_table(char *schedule_file)
{
static	char	ModuleName[]="load_schedule_table";
register	int	i,j;
FILE	*fp;
char	record[1024];
char	field[1024];
int	field_no = 0;
char	pgm_name[100];
int	pgm_found = ISP_NOTFOUND, grp_found = ISP_NOTFOUND;
int	load_entry = 0;			/* decide whether to load entry */

tot_schedules = 0;

sprintf(log_buf, "Loading %s table....", schedule_file);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
if ((fp=fopen(schedule_file, "r")) == NULL)
	{
	sprintf(log_buf, ISP_EOPEN_FILE, schedule_file, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
while (fgets(record, sizeof(record), fp) != NULL)
	{
	load_entry = 1;			/* load the entry */
	for (field_no = 1; field_no <= MAX_SCHEDULE_FIELD; field_no ++)
		{
		field[0] = '\0';
		if (get_field(record, field_no, field) < 0)
			{
			sprintf(log_buf, ISP_EFIELD, schedule_file, field_no, tot_schedules, record);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			load_entry = 0;		/* don't load entry */
			/* return (ISP_FAIL); */
			}
		if (load_entry == 0)		/* skip record for errors */
			break;
		switch(field_no)
			{
			case 	SERVER_NAME:
				schedule[tot_schedules].srvtype[0] = '\0';
				sprintf(schedule[tot_schedules].srvtype, "%s", field);
				break;
			case 	MACHINE_NAME:
				schedule[tot_schedules].machine[0] = '\0';
				sprintf(schedule[tot_schedules].machine, "%s", field);
				break;
			case 	DESTINAION:
				schedule[tot_schedules].destination[0] = '\0';
				sprintf(schedule[tot_schedules].destination, "%s", field);
				break;
			case 	ORIGINATION:
				schedule[tot_schedules].origination[0] = '\0';
				sprintf(schedule[tot_schedules].origination, "%s", field);
				break;
			case	PRIORITY:
				schedule[tot_schedules].priority = 0;
				schedule[tot_schedules].priority = atoi(field);
				break;
			case 	RULE:
				schedule[tot_schedules].rule = 0;
				schedule[tot_schedules].rule = atoi(field);
				break;
			case 	START_DATE:
				schedule[tot_schedules].start_date[0] = '\0';
				sprintf(schedule[tot_schedules].start_date, "%s", field);
				break;
			case 	STOP_DATE:
				schedule[tot_schedules].stop_date[0] = '\0';
				sprintf(schedule[tot_schedules].stop_date, "%s", field);
				break;
			case	START_TIME:
				schedule[tot_schedules].start_time[0] = '\0';
				sprintf(schedule[tot_schedules].start_time, "%s", field);
				break;
			case 	STOP_TIME:
				schedule[tot_schedules].stop_time[0] = '\0';
				sprintf(schedule[tot_schedules].stop_time, "%s", field);
				break;
			case 	PROGRAM_NAME:	
				schedule[tot_schedules].program[0] = '\0';
				sprintf(schedule[tot_schedules].program, "%s", field);
				if ((int)strlen(schedule[tot_schedules].program) > MAX_APPL_NAME)
					{
					sprintf(log_buf, "Ignore scheduling table entry for %s : Length of Application name too long, limit = %d", schedule[tot_schedules].program, MAX_APPL_NAME);
					LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
					continue;
					}
				break;
			default :
				sprintf(log_buf, "Field %d is invalid field number", field_no);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				break;
			} /*switch */
		} /* for */
	if (load_entry == 0)
		continue;		/* corrupted entry */
#ifdef DEBUG_TABLES
sprintf(log_buf, "Service = %s", schedule[tot_schedules].srvtype);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Machine = %s", schedule[tot_schedules].machine);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Destination = %s", schedule[tot_schedules].destination);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Origination = %s", schedule[tot_schedules].origination);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Priority = %d", schedule[tot_schedules].priority);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Rule = %d", schedule[tot_schedules].rule);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Start Date = %s", schedule[tot_schedules].start_date);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Stop Date = %s", schedule[tot_schedules].stop_date);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Start Time = %s", schedule[tot_schedules].start_time);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Stop Time = %s", schedule[tot_schedules].stop_time);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Program = %s", schedule[tot_schedules].program);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
#endif
	/* check if program exists , if not exists don't load the entry */
	if (access(schedule[tot_schedules].program, R_OK | X_OK) != 0)
		{
		sprintf(log_buf, ISP_EFILE, schedule[tot_schedules].program, errno, schedule[tot_schedules].destination, schedule[tot_schedules].origination);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		load_entry = 0;			/* don't load entry */
		}
	/* find and load program name */
	/* get basename of program */
	sprintf(pgm_name, "%s", schedule[tot_schedules].program); 
	pgm_found = ISP_NOTFOUND;
	for (i=0; i< tot_pgmrefs; i++)
		{
		if (strcmp(pgm_name, pgmref[i].program_name) == 0)
			{
			sprintf(schedule[tot_schedules].appl_grp_name, "%s", pgmref[i].appl_grp_name);
			pgm_found = ISP_FOUND;
			break;
			}
		}	
	/* if program found in program ref now check in application reference */
	if (pgm_found == ISP_FOUND)
		{
		grp_found = ISP_NOTFOUND;
		/*  find and load application name and maxium instances */
		for (j=0; j < tot_apprefs; j++)
			{
			if (strcmp(schedule[tot_schedules].appl_grp_name, appref[j].appl_grp_name) == 0)
				{
				sprintf(schedule[tot_schedules].acct_code, "%s", appref[j].acct_code);
				schedule[tot_schedules].max_instance = appref[j].max_instance;
				grp_found = ISP_FOUND;
				break;
				}
			} /* for */	
		} /* if */
	else
		{ /* not found */
		sprintf(log_buf, "WARNING: Program Name = %s is not found in program reference file, program will not be started by %s server. Scheduling table entry for (DNIS, ANI) = (%s, %s) is ignored.", schedule[tot_schedules].program, object_name, schedule[tot_schedules].destination, schedule[tot_schedules].origination);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		load_entry = 0;			/* don't load entry */
		continue;
		}
	/* if application group not in program reference */
	if (pgm_found == ISP_FOUND && grp_found == ISP_NOTFOUND)
		{
		sprintf(log_buf, "WARNING: Program Name = %s Application Name : %s is not found in application reference file, program will not be started by %s server. Scheduling table entry for (DNIS, ANI) = (%s, %s) is ignored.", schedule[tot_schedules].program, schedule[tot_schedules].appl_grp_name, object_name, schedule[tot_schedules].destination, schedule[tot_schedules].origination);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		load_entry = 0;			/* don't load entry */
		continue;
		}
#ifdef DEBUG_TABLES
sprintf(log_buf, "Application Group = %s", schedule[tot_schedules].appl_grp_name);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Accounting Code = %s", schedule[tot_schedules].acct_code);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
sprintf(log_buf, "Max Instances = %d", schedule[tot_schedules].max_instance);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
#endif

	if (load_entry == 1)			/* load entry is ok */
		tot_schedules ++;
	} /* while end of file */

(void) fclose(fp);

sprintf(log_buf, "Total entries loaded from scheduling table = %d.", tot_schedules);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

return (ISP_SUCCESS);
} /* load_schedule_table */
/*-------------------------------------------------------------------
load_appref_table(): This Routine load appref table into memory.
--------------------------------------------------------------------*/
int	load_appref_table(char *appref_file)
{
static	char	ModuleName[]="load_appref_table";
FILE	*fp;
char	record[1024];
char	field[1024];
int	field_no = 0;
int	load_entry = 0;			/* decide whether to load entry */

if (Turnkey_License)
{
	load_appref_pgmref_from_license();
	return(ISP_SUCCESS);
}

tot_apprefs = 0;

sprintf(log_buf, "load_appref_table(): Loading %s table", appref_file);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);

if ((fp=fopen(appref_file, "r")) == NULL)
	{
	sprintf(log_buf, ISP_EOPEN_FILE, appref_file, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
while (fgets(record, sizeof(record), fp) != NULL)
	{
	load_entry = 1;			/* load the entry */
	for (field_no = 1; field_no <= MAX_APPREF_FIELD; field_no ++)
		{
		field[0] = '\0';
		if (get_field(record, field_no, field) < 0)
			{
			sprintf(log_buf, ISP_EFIELD, appref_file, field_no, tot_apprefs, record);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			load_entry = 0;		/* don't load entry */
			/* return (ISP_FAIL); */
			}
		if (load_entry == 0)		/* skip record for errors */
			break;
		switch(field_no)
			{
			case 	APPL_GRP_NAME:
				sprintf(appref[tot_apprefs].appl_grp_name, "%s", field);
				break;
			case 	ACCT_CODE:
				sprintf(appref[tot_apprefs].acct_code, "%s", field);
				break;
			case	MAX_INSTANCES:
				appref[tot_apprefs].max_instance = atoi(field);
				break;
			default :
				sprintf(log_buf, "File = %s, Field %d is invalid field number", appref_file, field_no);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				break;
			} /*switch */
		} /* for */
	if (load_entry == 0)
		continue;		/* corrupted entry */
	sprintf(log_buf, "Application Group Name = %s", appref[tot_apprefs].appl_grp_name);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "Accounting Code = %s", appref[tot_apprefs].acct_code);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "Maxium Instances = %d", appref[tot_apprefs].max_instance);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	tot_apprefs ++;
	} /* while end of file */

(void) fclose(fp);

#ifdef DEBUG_TABLES
sprintf(log_buf, "Total entries loaded from Application Group Reference table = %d.", tot_apprefs);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
#endif

return (ISP_SUCCESS);
} /* load_appref_table */

/*-------------------------------------------------------------------
load_pgmref_table(): This Routine load pgmref table into memory.
--------------------------------------------------------------------*/
int	load_pgmref_table(char *pgmref_file)
{
static	char	ModuleName[]="load_pgmref_table";
FILE	*fp;
char	record[1024];
char	field[1024];
int	field_no = 0;
int	load_entry = 0;			/* decide whether to load entry */

if (Turnkey_License)
{
	/* No need to load pgmref, it's loaded with appref */
	return(ISP_SUCCESS);
}
tot_pgmrefs = 0;

sprintf(log_buf, "load_pgmref_table(): Loading %s table", pgmref_file);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
if ((fp=fopen(pgmref_file, "r")) == NULL)
	{
	sprintf(log_buf, ISP_EOPEN_FILE, pgmref_file, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
while (fgets(record, sizeof(record), fp) != NULL)
	{
	load_entry = 1;			/* load the entry */
	for (field_no = 1; field_no <= MAX_PGMREF_FIELD; field_no ++)
		{
		field[0] = '\0';
		if (get_field(record, field_no, field) < 0)
			{
			sprintf(log_buf, ISP_EFIELD, pgmref_file, field_no, tot_pgmrefs, record);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			load_entry = 0;		/* don't load entry */
			/* return (ISP_FAIL); */
			}
		if (load_entry == 0)		/* skip record for errors */
			break;
		switch(field_no)
			{
			case 	PROGRAM:	
				sprintf(pgmref[tot_pgmrefs].program_name, "%s", field);
				break;
			case 	APPL_GRP:
				sprintf(pgmref[tot_pgmrefs].appl_grp_name, "%s", field);
				break;
			default :
				sprintf(log_buf, "File = %s, Field %d is invalid field number", pgmref_file, field_no);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				break;
			} /*switch */
		} /* for */
	if (load_entry == 0)
		continue;		/* corrupted entry */
	sprintf(log_buf, "Program Name = %s", pgmref[tot_pgmrefs].program_name);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	sprintf(log_buf, "Application Group Name = %s", pgmref[tot_pgmrefs].appl_grp_name);
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	tot_pgmrefs ++;
	} /* while end of file */

(void) fclose(fp);

#ifdef DEBUG_TABLES
sprintf(log_buf, "Total entries loaded from Program Reference table = %d.", tot_pgmrefs);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
#endif

return (ISP_SUCCESS);
} /* load_pgmreference_table */

/*-------------------------------------------------------------------
This routine gets the value of desired field from data record.
-------------------------------------------------------------------*/
int find_application(requester, resource_index, token1, token2, application, group)
int	requester;		/* requester SCHEDULER/DYNAMIC_MANAGER */
int	resource_index;		/* resource index in resource table */
char	*token1;		/* DNIS */
char	*token2;		/* ANI */
char	*application;
char	*group;
{
static	char	ModuleName[]="find_application";
struct	schedule record;
int	ret;
/*
sprintf(log_buf, "(requester = %d, index = %d, token1 =<%s>, token2 = <%s>)", requester, resource_index, token1, token2);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
*/
/* find out program name */
if((strcmp(resource[resource_index].res_state,"STATIC")==0) && 
			(strcmp(resource[resource_index].res_type,"ISDN")==0))
	{
	if (check_data_token(STATIC_APPL, token1, token2, &record) != ISP_SUCCESS)
		return (ISP_FAIL);
	}
else
	{
	if (check_data_token(TOKEN1_APPL, token1, token2, &record) != ISP_SUCCESS)
		return (ISP_FAIL);
	}

/* after finding application for given token successfully,
	following are the criteria to start application */
/* check server type is same as define in command line object code (argv[1]) */
if (strcmp(record.srvtype, object_code) != 0)
	{
	if (database_hit == 1)
		{
		sprintf(log_buf, "Application %s is not started, (static token = %s) is schedule for %s Server and this server is %s", record.program, token1, record.srvtype, object_name);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		}
	return (ISP_FAIL);
	}
/* 1. check if application schedule is for same machine */
if((strcmp(object_machine_name, record.machine) != 0) && (strcmp("*", record.machine) != 0))
	{
	if (database_hit == 1)
		{
		sprintf(log_buf, "Application %s is not started, (static token = %s) is schedule for machine %s, and %s server name is %s", record.program, token1, record.machine, object_name, object_machine_name);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		}
	return (ISP_FAIL);
	}
/* 3. check date and time rule if ANALOG | ISDN & STATIC */
if (object == TEL || object == SNA || object == TCP)
	{
	if (((strcmp(resource[resource_index].res_type, "ANALOG") == 0 || 
	strcmp(resource[resource_index].res_type, "ISDN") == 0 ||  /* isdn and static */
	strcmp(resource[resource_index].res_type, "LU2") == 0 ||  /* sna */
	strcmp(resource[resource_index].res_type, "TELNET") == 0 ||  /* tcp */
	strcmp(resource[resource_index].res_type, "RS232") == 0 )/* tcp */
	&& 
	strcmp(resource[resource_index].res_state,"STATIC") == 0) 
	|| requester == DYNAMIC_MANAGER)
		{
		if ((ret = check_date_time_rule(resource[resource_index].res_no, record.program, record.start_date, record.stop_date, record.start_time, record.stop_time, record.rule)) != ISP_SUCCESS)
			{
			if (ret != -1)		/* not normal failure */
				{
				if (database_hit == 1)
					{
					switch (ret)
						{
						case	1: /* rule failed */
							sprintf(log_buf, "Rule criteria are not met, Rule(%d) failed for Program = %s for token %s, program not ready to start. start_date = %d, stop_date = %d, start_time = %d, stop_time = %d", record.rule, record.program, token1, atoi(record.start_date), atoi(record.stop_date), atoi(record.start_time), atoi(record.stop_time));
							break;
						case	2: /* invalid input */
							sprintf(log_buf, "Invalid input parameters, Rule(%d) failed for Program = %s for token %s, program not ready to start. start_date = %d, stop_date = %d, start_time = %d, stop_time = %d", record.rule, record.program, token1, atoi(record.start_date), atoi(record.stop_date), atoi(record.start_time), atoi(record.stop_time));
							break;
						case	3: /* logic error */
							sprintf(log_buf, "Internal logic error, Rule(%d) failed for Program = %s for token %s, program not ready to start. start_date = %d, stop_date = %d, start_time = %d, stop_time = %d", record.rule, record.program, token1, atoi(record.start_date), atoi(record.stop_date), atoi(record.start_time), atoi(record.stop_time));
							break;
						case	4: /* rule not implemented */
							sprintf(log_buf, "Program  Rule(%d) failed for Program = %s for token %s, program not ready to start. Rule not implemented", record.rule, record.program, token1);
							break;
						default :
							sprintf(log_buf, "Unknown return code from rule, return code = %d, Rule(%d) failed for Program = %s for token %s, program not ready to start. start_date = %d, stop_date = %d, start_time = %d, stop_time = %d", ret, record.rule, record.program, token1, atoi(record.start_date), atoi(record.stop_date), atoi(record.start_time), atoi(record.stop_time));
							break;
						} /* switch */		
					if (database_hit == 1)
						{
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
						}
					} /* if */
				} /* if */
			return (ISP_FAIL);
			}
		else
			{
			if(strcmp(resource[resource_index].res_type, "ISDN") == 0 && strcmp(resource[resource_index].res_state,"STATIC") == 0)
				{
				if(requester == DYNAMIC_MANAGER)
					sprintf(application, "%s", record.program);
				else
					sprintf(application, "%s", resource[resource_index].res_usage);
				}
			else
				sprintf(application, "%s", record.program);
			sprintf(group, "%s", record.acct_code);
			sprintf(log_buf, "Program = %s(%s) for token %s, state = ready to run.", application, record.program, token1);
			LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
			return (ISP_SUCCESS);
			}
		} /* for analog and static */
	else if (strcmp(resource[resource_index].res_type, "ISDN") == 0 && 
		strcmp(resource[resource_index].res_state,"DYN_MGR") == 0)
		{
		/* get dynamic manager name from resource table */
		sprintf(application, "%s",resource[resource_index].static_dest);
		sprintf(group, "%s", record.acct_code);
		sprintf(log_buf, "Program = %s for token %s, state = ready to run.", resource[resource_index].static_dest, token1);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		return (ISP_SUCCESS);
		}
	else if (strcmp(resource[resource_index].res_type, "ISDN") == 0 && 
		strcmp(resource[resource_index].res_state,"STATIC") == 0)
		{
		/* get dynamic manager name from resource table */
		sprintf(application, "%s", resource[resource_index].res_usage);
		sprintf(group, "%s", record.acct_code);
		sprintf(log_buf, "Program = %s for token %s, state = ready to run.", resource[resource_index].static_dest, token1);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		return (ISP_SUCCESS);
		}
	else
		{
		if (database_hit == 1)
			{
			sprintf(log_buf, "Resource type %s and state %s is not supported. Static Destination %s, can't find application.", resource[resource_index].res_type,resource[resource_index].res_state, resource[resource_index].static_dest);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			}
		return (ISP_FAIL);
		
		}
	} /* all Object */
else
	{
	if (database_hit == 1)
		{
		sprintf(log_buf, "object = %d not supported.", object);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		}
	}
return (ISP_FAIL);
} /* find_application */
/*------------------------------------------------------------
This routine check the token information.
and this routine is called for ISDN applications.
--------------------------------------------------------------*/
int	check_data_token(match_rule, token1, token2, record)
int	match_rule;		/* matching rule */
char	*token1;		/* token 1  - DNIS */
char	*token2;		/* token 2 - ANI */
struct	schedule *record;	/* schedule record */
{
static	char	ModuleName[]="check_data_token";
register 	int	i;
char	dnis[50];
char	ani[50];
char    pattern[40];
int	ret;

sprintf(dnis, "%s", token1);
sprintf( ani, "%s", token2);
/*
sprintf(log_buf, "parameter (match criteria = %d, token1 = <%s>, token2 = <%s>)", match_rule, dnis, ani);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
*/

if (token1 == NULL || (int)strlen(token1) == 0)
	{
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, "token1 value NULL");
	return (ISP_FAIL); 
	}

if (match_rule == TOKEN_APPL || match_rule == TOKEN1_APPL)
	{
	ret = lookForDnisMatch(match_rule, 1, dnis, ani, record);
	if(ret == ISP_SUCCESS)
		return(ISP_SUCCESS);
	else
		{
		ret = lookForDnisMatch(match_rule, 2, dnis, ani, record);
		if(ret == ISP_SUCCESS)
			return(ISP_SUCCESS);
		}
	} /* if */
if (match_rule == STATIC_APPL)
	{
	ret = lookForDnisMatch(match_rule, 1, dnis, ani, record);
	if(ret == ISP_SUCCESS)
		return(ISP_SUCCESS);
	}

if (match_rule == TOKEN2_APPL)
	{
	for (i=0; i < tot_schedules; i++)
		{
		if (strcmp(schedule[i].origination, ani) == 0)
			{
			if (check_date_time_rule("RES", schedule[i].program, schedule[i].start_date, schedule[i].stop_date, schedule[i].start_time, schedule[i].stop_time, schedule[i].rule) != ISP_SUCCESS)
				{
				/* if date and time rule failed find */
				/* next match */
				continue;
				}
			/* found token 2 */
			sprintf(record->srvtype, "%s", schedule[i].srvtype);
			sprintf(record->machine, "%s", schedule[i].machine);
			sprintf(record->destination, "%s", schedule[i].destination);
			sprintf(record->origination, "%s", schedule[i].origination);
			record->priority = schedule[i].priority;
			record->rule     = schedule[i].rule;
			sprintf(record->start_date, "%s", schedule[i].start_date);
			sprintf(record->stop_date, "%s", schedule[i].stop_date);
			sprintf(record->start_time, "%s", schedule[i].start_time);
			sprintf(record->stop_time, "%s", schedule[i].stop_time);
			sprintf(record->program, "%s", schedule[i].program);
			sprintf(record->acct_code, "%s", schedule[i].acct_code);
			sprintf(record->appl_grp_name, "%s", schedule[i].appl_grp_name);
			record->max_instance = schedule[i].max_instance;
			return (ISP_SUCCESS);
			}
		} /* for */
	} /* if */

if (database_hit == 1)
	{
	switch(object)
		{
		case	TEL:
			sprintf(log_buf, ISP_ETEL_MATCH, token1, token2);
			break;
		case	TCP:
		case	SNA:
		case	WSS:
			sprintf(log_buf, ISP_EMATCH, token1);
			break;
		default:
			sprintf(log_buf, ISP_ETEL_MATCH, token1, token2);
			break;
		}
	LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
	}

return (ISP_FAIL);				
} /* check_data_token */
/*---------------------------------------------------------------------------
This routine check the date and time valid to execute the application.
------------------------------------------------------------------------------*/
int 	check_date_time_rule(resource_name, program, start_date_str, stop_date_str, start_time_str, stop_time_str, rule)
char	*resource_name;
char	*program;
char	*start_date_str; 
char	*stop_date_str; 
char	*start_time_str; 
char	*stop_time_str; 
int	rule; 
{
static	char	ModuleName[]="check_date_time_rule";
time_t	now;
struct	tm	*t;				/* time structure */
int	start_date, stop_date, start_time, stop_time, ret;

start_date = atoi(start_date_str);
stop_date = atoi(stop_date_str);
start_time = atoi(start_time_str);
stop_time  = atoi(stop_time_str);

if ((time(&now) == (time_t) -1) || ((t=localtime(&now)) == NULL) )
	{
	sprintf(log_buf, ISP_ESYSTIME, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
/* debug line */
#ifdef DEBUG_RULES
sprintf(log_buf, "Resource Name = %s, start date = %d, stop date = %d, start time = %d, stop time = %d, year = %d, month = %d, week day = %d, month day = %d, hour = %d, minutes = %d, seconds = %d", resource_name, start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
#endif
switch(rule)
	{
	case	0:
		ret = sc_rule0(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	1:
		ret = sc_rule1(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	2:
		ret =  sc_rule2(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	3:
		ret = sc_rule3(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	4:
		ret =  sc_rule4(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	5:
		ret =  sc_rule5(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	6:
		ret = sc_rule6(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	7:
		ret = sc_rule7(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	8:
		ret = sc_rule8(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	case	9:
		ret =  sc_rule9(start_date, stop_date, start_time, stop_time, t->tm_year, t->tm_mon, t->tm_wday, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
		break;
	default:
		if (database_hit == 1)
			{
 			sprintf(log_buf, ISP_ERULE, rule);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			}
		return (ISP_FAIL);
	} /* rule */
if (ret == 0)
	return (ISP_SUCCESS);
return (ret);
} /* check_date_time_rule */
/*------------------------------------------------------
Following routine send message to dynamic manager.
--------------------------------------------------------*/
int	inform_dyn_mgr(int request, int found, char *application, char *customer_name, int pid)
{
static	char	ModuleName[]="inform_dyn_mgr";
Mesg	mesg1;
Mesg	*mesgptr = &mesg1;

mesg1.mesg_type = (long) pid;
sprintf(mesg1.mesg_data, "%d %s %s", found, application, customer_name);
/* check requester exists */
/* check if application exists */
if (kill(pid, 0) == -1)	
	{
	if (errno == ESRCH) 
		{
		sprintf(log_buf, "Unable to send message <%s> to pid (%d), errno=%d. Process does not exist.", mesg1.mesg_data, pid, errno);
		LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
		return (-1);
		}
	}
ret_code = msgsnd(dyn_mqid, mesgptr, MSIZE-1, IPC_NOWAIT);
if (ret_code != 0)
	{
	sprintf(log_buf, ISP_EMSGSND, application, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
sprintf(log_buf, "Sending message to dynamic manager : type = %ld, data = %s.", mesg1.mesg_type, mesg1.mesg_data);
LogMsg(ModuleName, ISP_DEBUG_DETAIL, log_buf);
return (ISP_SUCCESS);
} /* inform_dyn_mgr */
/*----------------------------------------------------------
Following routine update shared memory slot if necessary.
-----------------------------------------------------------*/
void update_shmem()
{
static	char	ModuleName[]="update_shmem";
int	i, pid_int=0;
int	slot_no=0;
char	field[256];			/* needs to be changed */
int	res_found = ISP_NOTFOUND;
char	file_name[MAX_PROGRAM];
char	application[MAX_PROGRAM];
char	group[MAX_GROUP];
char	pid_str[10];
char	status_str[10];
char	res_name[20];

for(slot_no = 0; slot_no < MAX_SLOT && slot_no < tot_resources; slot_no++)
	{
	/* read application status */
	(void)read_fld(tran_tabl_ptr, slot_no, APPL_STATUS, status_str);     
	/* if application busy skip record */
	if (atoi(status_str) == STATUS_BUSY)
		continue;
	/* read application pid */
	(void)read_fld(tran_tabl_ptr, slot_no, APPL_PID, pid_str);     
	sscanf(pid_str, "%d", &pid_int);
	/* if application already running */
	if (pid_int > 0)
		{
		continue;	
		}
	/* read application name */
	(void)read_fld(tran_tabl_ptr, slot_no, APPL_NAME, field);     
	(void)read_fld(tran_tabl_ptr, slot_no, APPL_RESOURCE, res_name);     
	/* start finding resource in resource table and load only one time */
	res_found = ISP_NOTFOUND;
	for (i=0; i < tot_resources; i++)
		{
		/* find out resource matching in resource definition table */
		if (strcmp(res_name, resource[i].res_no) == 0)
			{
			res_found = ISP_FOUND;
			break;
			}
		} /* for all resource */
	/* ignore the entry for reserve port */
	if (res_found == ISP_FOUND && strcmp(resource[i].res_usage, RESERVE_PORT) == 0)
			res_found = ISP_NOTFOUND;
	if (res_found==ISP_FOUND && strcmp(resource[i].res_usage, SKIP_PORT) == 0)
			res_found = ISP_NOTFOUND;
	if (res_found == ISP_FOUND)
		{
		file_name[0] = '\0';
		application[0] = '\0';
		/* for ISDN dynamic application fire dynamic manager */
		switch(object)
			{
			case	TEL:
				if (strcmp(resource[i].res_type, "ISDN") == 0 && strcmp(resource[i].res_state, "DYN_MGR") == 0)
					{
					sprintf(application, "%s", resource[i].static_dest);
					}
				else
					{
					if (find_application(SCHEDULER, i, resource[i].static_dest, "", file_name, group) != ISP_SUCCESS)
						{
						/* delete application if not busy */
						if ((atoi(status_str) == STATUS_IDLE || atoi(status_str) == STATUS_INIT) && (atoi(pid_str) != 0))
							{
							sprintf(log_buf, ISP_ETERM, field, pid_int);
							LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
							(void)kill ((pid_t)atoi(pid_str), SIGTERM);
							continue;
							}
						sprintf(application, "%s", "N/A");
						}
					else
						{
						sprintf(application, "%s", file_name);
						}
					} /* for non ISDN resource */
				(void) update_application(i, slot_no, application);
				break;

			case	TCP:
				if (find_application(SCHEDULER, i, resource[i].static_dest, "", file_name, group) != ISP_SUCCESS)
					{
					/* delete application if not busy */
					if ((atoi(status_str) == STATUS_IDLE || atoi(status_str) == STATUS_INIT) && (atoi(pid_str) != 0))
						{
						sprintf(log_buf, ISP_ETERM, field, pid_int);
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
						(void)kill ((pid_t)atoi(pid_str), SIGTERM);
						continue;
						}
					sprintf(application, "%s", "N/A");
					}
				else
					{
					sprintf(application, "%s", file_name);
					}
				(void) update_application(i, slot_no, application);
				break;

			case	SNA:
				if (find_application(SCHEDULER, i, resource[i].static_dest, "", file_name, group) != ISP_SUCCESS)
					{
					/* delete application if not busy */
					if ((atoi(status_str) == STATUS_IDLE || atoi(status_str) == STATUS_INIT) && (atoi(pid_str) != 0))
						{
						sprintf(log_buf, ISP_ETERM, field, pid_int);
						LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
						(void)kill ((pid_t)atoi(pid_str), SIGTERM);
						continue;
						}
					sprintf(application, "%s", "N/A");
					}
				else
					{
					sprintf(application, "%s", file_name);
					}
				(void) update_application(i, slot_no, application);
				break;
			default :
				break;
			} /* switch */		
		} /* if resource found */
	} /* for all slot */
return;
} /* update_shmem */
/*--------------------------------------------------------------
This routine gets the value of desired field from data record.
---------------------------------------------------------------*/
int get_field(buffer, fld_num, field)
const   char    buffer[];               /* data record */
int     fld_num;                        /* field # in the buffer */
char    field[];                        /* buffer to fill with the field name */
{
register        int     i;
int     fld_len = 0;                    /* field length */
int     state = OUT;                    /* current state IN or OUT */
int     wc = 0;                         /* word count */

field[0] = '\0';
if( fld_num < 0)
	{
        return (-1);
	}

for(i=0; i < (int)strlen(buffer); i++) 
        {
        if(buffer[i] == FIELD_DELIMITER || buffer[i] == '\n')
                {
                state = OUT;
                if(buffer[i] == FIELD_DELIMITER && buffer[i-1] == FIELD_DELIMITER)
                        ++wc;
                }
        else if (state == OUT)
                {
                state = IN;
                ++wc;
                }
        if (fld_num == wc && state == IN)
		{
                field[fld_len++] = buffer[i];
		}
        if (fld_num == wc && state == OUT)
		{
                break;
		}
        } /* for */

if (fld_len > 0)                                /*  for last field */
        {
        field[fld_len] = '\0';
        while(field[0] == ' ')
                {
                for (i=0; field[i] != '\0'; i++)
                        field[i] = field[i+1];
                }
        fld_len = strlen(field);
        return (fld_len);                       /* return field length*/
        }
return (-1);                                    /* return error */
} /* get_field() */
/*--------------------------------------------------------------------------
application_instance_manager(): this routine update instance for application
----------------------------------------------------------------------------*/
int application_instance_manager(command, program_name, res_id)
int	command;			/* ADD, DELETE */
char	*program_name;
char	*res_id;
{
static	char	mod[]="application_instance_manager";
int	i, j, found = ISP_NOTFOUND;
char	appl_grp_name[MAX_GROUP];
char	tmp_pgm_name[MAX_PROGRAM];

for (i=0; i< tot_pgmrefs; i++)
	{
	/* find program(basename) in program reference */
	sprintf(tmp_pgm_name, "%s", program_name);
	if (strcmp(tmp_pgm_name, pgmref[i].program_name) == 0)
		{
		sprintf(appl_grp_name, "%s", pgmref[i].appl_grp_name);
		found = ISP_FOUND;
		break;
		}
	}	
if (found != ISP_FOUND)
	{
	/* instance may is dynamic manager */
	/*
	sprintf(log_buf, ISP_EPGM, program_name);
	LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
	*/
	return (-1);
	}
found = ISP_NOTFOUND;
/* find  group in application reference */
for (j=0; j < tot_apprefs; j++)
	{
	if (strcmp(appl_grp_name, appref[j].appl_grp_name) == 0)
		{
		found = ISP_FOUND;
		break;
		}
	} /* for */	

if (found != ISP_FOUND)
	{
	if (database_hit == 1)
		{
		sprintf(log_buf, ISP_EPGMGRP, appl_grp_name);
		LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
		}
	return (-1);
	}

switch(command)
	{
	case	ISP_ADD_INSTANCE:
		appref[j].curr_instance = appref[j].curr_instance + 1;		
		sprintf(log_buf, "Adding instance, app <%s>, port %s, current instance %d", program_name, res_id, appref[j].curr_instance);
		LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
		break;
	case	ISP_DELETE_INSTANCE:
		appref[j].curr_instance = appref[j].curr_instance - 1;		
		sprintf(log_buf, "Deleting instance, app <%s>, port %s, current instance %d", program_name, res_id, appref[j].curr_instance);
		LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
		break;
	case	ISP_CHECK_MAX_INSTANCE:
		if (appref[j].curr_instance >= appref[j].max_instance)
			{
			sprintf(log_buf, "Maximum instance reached for program <%s>, resource <%s>, account code <%s>. Max instance=%d. Current instance=%d.", 
			program_name, res_id, appref[j].acct_code, 
			appref[j].max_instance, appref[j].curr_instance);
			sprintf(log_buf, ISP_EMSG, log_buf);
			LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
			if (database_hit == 1)
				{
				sprintf(log_buf, "Can't start program <%s>, resource <%s>, Account code <%s>, Application group <%s>. Maximum allowable instances (%d) are already running.", 
				program_name, res_id, appref[j].acct_code, appref[j].appl_grp_name, appref[j].max_instance);
				LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
				}
			return (-1);
			}
		break;
	default:
		sprintf(log_buf, ISP_ECMD, mod, command);		
		LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
		return (-1);
	} /* switch */
return (0);
} /* application_instance_manager */
/*--------------------------------------------------------------------
set_resource_type_flag(): This routine set the resource type flag 
			  to fire application.
--------------------------------------------------------------------*/
int set_resource_type_flag(char *resource_type, char *isdn_flag)
{
/* for resource type analog/isdn */
if (strcmp(resource_type, "ANALOG") == 0)
	{
	sprintf(isdn_flag, "%d", 1);
	}	
else if (strcmp(resource_type, "ISDN") == 0)
	{
	sprintf(isdn_flag, "%d", 2);
	}	
else
	{
	sprintf(isdn_flag, "%d", 0);
	}	
return (0);
} /* set_resource_type_flag() */
/*--------------------------------------------------------------------
set_resource_state_flag(): This routine set the resource state flag 
			  to fire application.
--------------------------------------------------------------------*/
int set_resource_state_flag(char *resource_state, char *state)
{
if (strcmp(resource_state, "STATIC") == 0)
	{
	sprintf(state, "%d", 1);
	}	
else if (strcmp(resource_state, "DYNAMIC") == 0)
	{
	sprintf(state, "%d", 2);
	}	
else
	{
	sprintf(state, "%d", 0);
	}	
return (0);
} /* set_resource_state_flag */

/*-----------------------------------------------------------------------------
resp_shutdown():
-----------------------------------------------------------------------------*/
void resp_shutdown()
{
static	char	ModuleName[]="resp_shutdown";
int	i;
int	tran_sig[MAX_PROCS];	/* (field 10) to store the signal status */

for(i=0; i<tran_proc_num; i++)
	tran_sig[i] = 2;
(void)write_arry(tran_tabl_ptr, APPL_SIGNAL, tran_sig);

if(OCSMgr_pid != 0)
	{
	(void) kill(OCSMgr_pid, SIGKILL);
	sprintf(log_buf, "Killing OCSMgr, pid %d.", OCSMgr_pid);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}
if(ArcGDynMgr_pid != 0)
	{
	(void) kill(ArcGDynMgr_pid, SIGTERM);
	sprintf(log_buf, "Killing ArcGDynMgr, pid %d.", ArcGDynMgr_pid);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	}
sprintf(log_buf, ISP_EMSG, "Responsibility received termination signal ...");
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
sprintf(log_buf, "%s", "Telecom Services shutdown complete.");
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
check_and_send_snmp_trap(3116, log_buf, SNMP_Group_Id);
exit (0);
} /* resp_shutdwon */

/*-----------------------------------------------------------------
update_application(): update the application into shared memory
------------------------------------------------------------------*/
int	update_application(int res_index, int shm_index, char *pgm_name)
{
static	char	ModuleName[] = "update_application";
char	appl_name[MAX_PROGRAM];
char	*ptr, *ptr1;
char	status_str[5];

sprintf(appl_name, "%s", pgm_name);
if (strlen(appl_name) > MAX_APPL_NAME)
	{
	sprintf(log_buf, 
	"Application name <%s> is too long. Maximum length is %d.", 
	appl_name, MAX_APPL_NAME);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (0);
	}
if((strcmp(appl_name, "N/A") != 0) && (strcmp(appl_name, DCHAN) != 0))
	{			/* if application exists */
	if (access(appl_name, R_OK|X_OK) != 0)
		{
		if (database_hit == 1)
			{
			sprintf(log_buf, ISP_EFILE, appl_name, errno, resource[res_index].res_no, "N/A");
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			}
		sprintf(appl_name, "%s", "N/A");
		}
	}
ptr = tran_tabl_ptr;
ptr += (shm_index*SHMEM_REC_LENGTH);
/* position the pointer to the field */
ptr += vec[APPL_NAME-1];			/* application start index */
ptr1 = ptr;
(void) memset(ptr1, ' ', MAX_APPL_NAME);
ptr += (MAX_APPL_NAME - strlen(appl_name));
(void) memcpy(ptr, appl_name, strlen(appl_name));
/* if application is in off status, turning it on */
appl_stat_arry[shm_index] = 0;
read_fld(tran_tabl_ptr, shm_index, APPL_STATUS, status_str);     
/*if((atoi(status_str)!=STATUS_OFF)&&(atoi(status_str)!=STATUS_CHNOFF)) */
if(atoi(status_str)!=STATUS_CHNOFF)
	{
		//sprintf(log_buf, " STATUS_INIT (3), port %d", shm_index);
		//LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	(void)write_fld(tran_tabl_ptr, shm_index, APPL_STATUS, STATUS_INIT);
	}
return (0);
} /* update_application */
/*-----------------------------------------------------------------
find_pu_name(): find pu name from sna resource.
------------------------------------------------------------------*/
/*--------------------------------------------------
LU - Resource file Description:

  0-8           Lu Name
  9-17          Pu Name
  18-21         Lu Number
  22-26         Connection Type
  27-59         Code Page
  60-250        Model Type
  251-315       Comment
  316-322       Port Number
----------------------------------------------------*/
#define LU_FILESIZE 323
#define PU_NAME 9

static	int	find_pu_name(res_name, pu_name)
char	*res_name;
char	*pu_name;
{
static	char	ModuleName[] = "find_pu_name";
char	data[512];
char	pu[20];
int	fd;
char	gateway_file[256];

sprintf(gateway_file, "%s/access/cdir/%s", isp_home, res_name);

if ((fd=open(gateway_file, O_RDONLY)) == -1)
	{
	sprintf(log_buf, ISP_EOPEN_FILE, gateway_file, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	sprintf(pu_name, "%s", "BAD");
	}
if(read(fd,&data,LU_FILESIZE)  == -1)
	{
	sprintf(log_buf, "Unable to read data from file %s, errno = %d, setting PUNAME = BAD", gateway_file, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	sprintf(pu_name, "%s", "BAD");
        }
else
	{
	sprintf(pu_name, "%s", &data[PU_NAME]);
	}
close(fd);
return (ISP_SUCCESS);
} /* find_pu_name */
/*--------------------------------------------------------------------
kill_all_app(): This module kills all application that are running.
----------------------------------------------------------------------*/
static	int	kill_all_app()
{
register	int	i;
(void) fill_vecs(tran_tabl_ptr, appl_pid);
for(i=0; i< tran_proc_num; i++)
	{
	if (appl_pid[i] != 0)
		(void) kill((pid_t)appl_pid[i], SIGTERM);
	}
return (0);
} /* kill_all_app */
/*--------------------------------------------------------------------------
Check for update table request.
---------------------------------------------------------------------------*/
int check_update_table_request()
{
static	char	ModuleName[] = "check_update_table_request";
static	time_t	last_time_modified;
char	reload_path[256];   
struct  stat    file_stat;

sprintf(reload_path, "%s/%s", lock_path, RELOAD_FILENAME);
/* check if reload file exists if not create one */
if (access(reload_path, R_OK) != 0)
	{
	if (creat(reload_path, 0644) != 0)
		{
		sprintf(log_buf, "Failed to create new reload file %s, errno = %d", reload_file, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (-1);
		} 
	}
if (stat(reload_path, &file_stat) == 0)
	{
	/* check if last modified time is changed */
	if (file_stat.st_mtime != last_time_modified)
		{
		last_time_modified = file_stat.st_mtime;
		return (0); 	/* last modification time change reload found */
		}
	} /* stat */
return (-1);
} /* check_update_table_request */
/*----------------------------------------------------------------------------
load_parameter_configuration(): This routine load configuration file for server.
-----------------------------------------------------------------------------*/
void load_parameter_configuration()
{
char	buf[100];
char	param[30];
char	cfg_file[256];
FILE	*cfp;
char	*ptr;

see_if_ResourceMgr_should_run();
switch(object)
	{
	case	TEL:
		sprintf(cfg_file, "%s/%s", table_path, TEL_PARM_CONFIG);
		break;
	case	TCP:
		sprintf(cfg_file, "%s/%s", table_path, TCP_PARM_CONFIG);
		break;
	case	SNA:
		sprintf(cfg_file, "%s/%s", table_path, SNA_PARM_CONFIG);
		break;
	default :
		return;
	} /* switch */
cfp = fopen(cfg_file, "r");
if (cfp == NULL)
	{
	sprintf(log_buf, "Unable to open <%s>. errno=%d. Setting default parameters.", cfg_file, errno);	
	LogMsg("load_parm_config", ISP_DEBUG_NORMAL, log_buf);
	return;
	}
while(fgets(buf, sizeof(buf), cfp) != NULL)
	{
	buf[(int)strlen(buf)-1] = '\0';

	/* set heartbeat parameters */
	if (strstr(buf, "HeartBeatInterval") != NULL)
		{
		sscanf(buf, "%[^=]=%s", param, heartbeat_interval);
		}
	/* set network services */
	if (strstr(buf, "NetServices") != NULL)
                {
                sscanf(buf, "%[^=]=%s", param, NetworkStatus);
                }

	/* for Telecom */
	if (object == TEL)
		{
		/* set language */
		if (strstr(buf, "DefaultLanguage") != NULL)
                	{
                	sscanf(buf, "%[^=]=%s", param, DefaultLang);
                	}
		}
	if (object == SNA)
		{	
		/* set access services */
		if (strncmp(buf, "AccessMode", 10) == 0)
                        {
                        sscanf(buf, "%[^=]=%s", param, AccessMode);
                        }
		}
	} /* while not eof */
fclose(cfp);


return;
}  /* load_parameter_configuration */

/*----------------------------------------------------------------------------
Go to the appropriate file (determined in this module) and see if the 
Resource Manager needs to be started. If so, set global var. start_ResMgr.
----------------------------------------------------------------------------*/
static void see_if_ResourceMgr_should_run() 
{
	static char mod[]="see_if_ResourceMgr_should_run";
	int rc;
	char filename[256];

	char res_mgr_info_file[]="GLOBAL_CONFIG";	
	char section[]="";
	char name[]="ResourceMgr";
	char default_value[]="ON";
	char value[64];
	int  max_buffer_size=64;

	/* If all else fails, make sure we start Resource Manager */	
	start_ResMgr = 1;

	/* Get the name of the config file where Resource Mgr info is stored. */
	rc=util_get_cfg_filename(res_mgr_info_file, filename, log_buf);
	if (rc != 0)
	{
		LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
		return;
	}

	rc = util_get_name_value(section, name, default_value,
                        value, max_buffer_size, filename, log_buf);
	if (rc != 0)
	{
		LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
		return;
	}

	if (strcmp(value,"ON") == 0)
		start_ResMgr = 1;
	else
		start_ResMgr = 0; 

	return;
}

/*-----------------------------------------------------------------------------
check_kill_app():This routine check for all application dead and does cleanup.
-----------------------------------------------------------------------------*/
static	void check_kill_app()
{
static 	char mod[]="check_kill_app";
register	int	appl_no, resno;
char	pid_str[10];
char	res_str[30];
char	program_name[30];
int	int_pid;

for(appl_no=0; appl_no<tran_proc_num; appl_no++)
	{
	/* read pid field */
	(void)read_fld(tran_tabl_ptr, appl_no, APPL_PID, pid_str);     
/*	(void)read_fld(tran_tabl_ptr, appl_no, APPL_RESOURCE, res_str);     
	(void)read_fld(tran_tabl_ptr, appl_no, APPL_NAME, program_name);  */
	int_pid = atoi(pid_str);
	if (kill(int_pid, 0) == -1)	/* check application exists */
		{
		if (errno == ESRCH) /* No process */
			{
			/* application cleanup function */
			(void) cleanup_app(int_pid, appl_no);
			read_fld(tran_tabl_ptr, appl_no,APPL_RESOURCE,res_str);
			/* reserve resource no more available to application */
			/* make resource free */
			for (resno = 0; resno <= MAX_PROCS; resno ++)
				{
				/* find the resource allocated to this proc */
				if (res_status[resno].pid  == atoi(pid_str) && strcmp(res_str, RESERVE_PORT) == 0)
					{
					res_status[resno].status = FREE; 
					res_status[resno].pid = 0;	
					/*
					sprintf(log_buf, "DEBUG: Application with pid=%d exited. Releasing reserve resource (%d) associated with it", 
					int_pid, resno);
					LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
					*/
					break;
					} /* if pid same */
				} /* for */
			} /* if process not exists */
		} /* kill */
	} /* for */

/* following code is for network services */
if (start_net_serv == 1)	/* if network service exists */
	{
	if (kill(net_serv_pid, 0) == -1)     /* check application exists */
                {
                if (errno == ESRCH) /* No process */
                        {
			/* restart network services */
			sprintf(log_buf, 
			"Network services for %s server stopped. pid=%d.", 
			object_name, net_serv_pid);
			LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
			start_netserv();
                        }
		}
	} /* if network services */

if (start_ResMgr == 1)	
	{
	if (kill(resmgr_pid, 0) == -1)    
                {
                if (errno == ESRCH) /* No process */
                        {
			sprintf(log_buf, 
			"ResourceMgr has stopped. pid=%d. Restarting.", 
			resmgr_pid);
			LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
			StartResourceMgr();
                        }
		}
	} 

if (start_OCSMgr == 1)	
	{
	if (kill(OCSMgr_pid, 0) == -1)    
                {
                if (errno == ESRCH) /* No process */
                        {
			sprintf(log_buf, 
			"OCSMgr has stopped. pid=%d. Restarting.", OCSMgr_pid);
			LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
			StartOCSMgr();
                        }
		}
	} 

if (start_ArcGDynMgr == 1)	
{
	if (kill(ArcGDynMgr_pid, 0) == -1)    
	{
		if (errno == ESRCH) /* No process */
		{
			sprintf(log_buf, 
			"ArcGDynMgr has stopped. pid=%d. Restarting.", ArcGDynMgr_pid);
			LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
			StartArcGDynMgr();
		}
	} 
}
/* check if pid exists */
if (object == SNA)
	{
	if (kill(access_pid, 0) == -1)
		{
		if (errno == ESRCH) 
			{
			sprintf(log_buf, "Access services for %s server have stopped. pid=%d. Restarting.", object_name, access_pid);
                        LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
                        start_sna_access();
			}
		}
	}

return;
} /* check_kill_app */
/*-----------------------------------------------------
start_netserv() : start network server for my server.
------------------------------------------------------*/
int	start_netserv()
{
int	ret;
char	net_serv_name[64];
char	net_serv_path[256];
char	ModuleName[]="start_netserv";

if (start_net_serv != 1)			/* netwok not co-resident */
	return (0);

switch(object)
	{
	case	TEL:
		sprintf(net_serv_path, "%s/%s", exec_path, TEL_NET_SERV);
		sprintf(net_serv_name, "%s", TEL_NET_SERV);
		break;
	case	TCP:
		sprintf(net_serv_path, "%s/%s", exec_path, TCP_NET_SERV);
		sprintf(net_serv_name, "%s", TCP_NET_SERV);
		break;
	case	SNA:
		sprintf(net_serv_path, "%s/%s", exec_path, SNA_NET_SERV);
		sprintf(net_serv_name, "%s", SNA_NET_SERV);
		break;
	default:
		sprintf(log_buf, ISP_EOBJ_NUM, object);	
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
		return (ISP_FAIL);
	} /* switch */

/* check if network services process exists */
ret = access(net_serv_path, R_OK | X_OK);
if(ret != 0)
	{
	sprintf(log_buf, "Failed to start Network Services for %s Server. "
	"errno=%d. Please fix the problem & re-start %s services.", 
	object_name, errno, object_name);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	start_net_serv = 0;
	return (ISP_FAIL);
	}
/* fire network services */
if ((net_serv_pid = fork()) == 0)
	{
	ret = execl(net_serv_path, net_serv_name, NULL);
	if (ret == -1)
		{
		sprintf(log_buf, 
		"Failed to start Network Services for %s Server. errno=%d.", 
		object_name, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 		check_and_send_snmp_trap(3039, log_buf, SNMP_Group_Id);
		}
	exit (0);
	}
sprintf(log_buf, "Starting Network Services for %s Server.  pid=%d.", 
						object_name, net_serv_pid);
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
return (0);
} /* start_netserv */
/*-----------------------------------------------------------------------------
check_net_config() : Check to see if Network Services should be run.
----------------------------------------------------------------------------*/
void	check_net_config()
{
if (strcmp(NetworkStatus,"ON") == 0) 
	start_net_serv = 1;
else
	start_net_serv = 0;
} /* check_net_config */

/*-----------------------------------------------------
start_sna_access() : start sna access software.
------------------------------------------------------*/
int	start_sna_access()
{
int	ret;
char	ModuleName[]="start_sna_access";
char	sna_access[100];
char	access_path[100];


sprintf(sna_access, "%s", "access");
if (object != SNA )
	return (0);

/* fire SNA access services */
if ((access_pid = fork()) == 0)
	{
	if (strncmp(AccessMode, "FORE", 4) == 0)
		{
		ret = execl("/usr/X/bin/xterm","xterm","+rs","-i","-T","SNA_Access","-E","access", (char *) 0);
		}
	else
		{ 
		ret = execlp("access","access","-b",(char *) 0);
		}
	if (ret == -1)
		{
		sprintf(log_buf, "Unable to start %s services for %s server execl system call failed, errno = %d", sna_access, object_name, errno);
		LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 		check_and_send_snmp_trap(3040, log_buf, SNMP_Group_Id);
		}
	exit (0);
	}
sleep (60);			/* give time to access come up */
set_access_pid();
sprintf(log_buf, "Starting %s services for %s server started PID = %d", sna_access, object_name, access_pid);
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
return (0);
} /* start_sna_access */
/*-----------------------------------------------------------------------------
get_free_port() : This function gets the first free port.
-----------------------------------------------------------------------------*/
void	get_free_port(requester, port_type, free_port, token1)
int	requester;
int	*port_type;
int	*free_port;
char	*token1;
{
register	int	j, k;
int	app_pid;
char	res_id[10];
char	res_pid[10];
char	status_str[10];
char	program_name[50];
int	available_port, field_num;
char	usage_type[20];

int descending = 0;
int even = 0;
int odd = 0;

*free_port = -1;
*port_type = 0;
if(strlen(token1) != 0)
	{	/* particular resource type is requested */
	for(field_num = 1; field_num <10; field_num++)
	{
		get_field(token1, field_num, usage_type);
		if(strcmp(usage_type, "NODEFAULT") == 0)
			return;	/* NODEFAULT specified by the application */
		if(strlen(usage_type) == 0)
			break;

		for(j=0; j<gMaxSections; j++)
		{
			descending = 0;
			even = 0;
			odd = 0;
			if(strcmp(gGivePortRule[j].section, usage_type) == 0)
			{
				switch(gGivePortRule[j].rule)
				{
					case RULE_ASCENDING:
						break;

					case RULE_ASCENDING_EVEN:
						even = 1;
						break;

					case RULE_ASCENDING_ODD:
						odd = 1;
						break;

					case RULE_DESCENDING:
						descending = 1;
						break;

					case RULE_DESCENDING_EVEN:
						even = 1;
						descending = 1;
						break;

					case RULE_DESCENDING_ODD:
						odd = 1;
						descending = 1;
						break;

					default:
						continue;
						break;
				}
				break;
			}
		}

		if(j < gMaxSections)
		{
			if(checkRuleAndGetPort(gGivePortRule[j].lastPortGiven, descending, 
				even, odd, &available_port, usage_type) == 0)
			{
				*free_port = available_port;
				gGivePortRule[j].lastPortGiven = available_port;	
				return;
			}
		}
	}

	for(field_num = 1; field_num <10; field_num++)
		{
		get_field(token1, field_num, usage_type);
		if(strcmp(usage_type, "NODEFAULT") == 0)
			return;	/* NODEFAULT specified by the application */
		if(strlen(usage_type) == 0)
			break;

		/* find first free port for particular usage */
		get_available_port(requester, &available_port, usage_type);
		if(available_port == -1)
			;/* no port of given type is available, continue */
		else
			{
			*free_port = available_port;
			return;
			}
		}
	}

/* find first free port of RESERV_PORT USAGE if available */
for(j=0; j <tot_resources; j++)
	{
	/* if port is requetser */
	if (atoi(resource[j].res_no) == requester)
			continue;
	if (strcmp(resource[j].res_usage, RESERVE_PORT) == 0)
		{
		sprintf(log_buf, "DEBUG: Found Reserve Resource %s Status = %d", resource[j].res_no, res_status[atoi(resource[j].res_no)].status);
		LogMsg("get_free_port", ISP_DEBUG_DETAIL, log_buf);
		if (res_status[atoi(resource[j].res_no)].status == FREE)
			{
			read_fld(tran_tabl_ptr,j,APPL_STATUS,status_str);
			if(atoi(status_str) == STATUS_CHNOFF)
				{
				sprintf(log_buf, "DEBUG: Found FREE Reserve Resource %s, but port is OFF", resource[j].res_no);
				LogMsg("get_free_port",ISP_DEBUG_DETAIL,log_buf);
				continue;
				}
			else
				{
				*free_port = atoi(resource[j].res_no);
				*port_type = RESERVE;
				return;
				}
			}
		} /* strcmp */
	} /* for */

/* find first free port of any usage */
for(j=0; j <tot_resources; j++)
	{
	/* if available port is requetser - skip */
	if (atoi(resource[j].res_no) == requester)
			continue;
	if (strcmp(resource[j].res_usage, TWO_WAY_PORT) == 0)
		{
		if (res_status[atoi(resource[j].res_no)].status == FREE)
			{
			(void)read_fld(tran_tabl_ptr,j,APPL_STATUS,status_str);
#ifdef DEBUG
			(void)read_fld(tran_tabl_ptr, j, APPL_PID, res_pid);     
			(void)read_fld(tran_tabl_ptr, j, APPL_NAME, program_name);     
			sprintf(log_buf, "DATA: Free port %d, status = %s pid = %s appl = %s", j, status_str, res_pid, program_name);
			LogMsg("get_free_port", ISP_DEBUG_DETAIL, log_buf);
#endif
			if(atoi(status_str) == STATUS_IDLE)
				{	
				*free_port = atoi(resource[j].res_no);
				for(k=0; k<tot_resources; k++)
					{
					/* search resource in shared memory */
					(void)read_fld(tran_tabl_ptr, k, APPL_RESOURCE, res_id);     
					if(atoi(res_id) ==  atoi(resource[j].res_no))
						{
						(void)read_fld(tran_tabl_ptr, k, APPL_PID, res_pid);     
						/* make the port free */
						sprintf(log_buf, "DEBUG: killing dynamic manager = %s", res_pid);
						LogMsg("get_free_port", ISP_DEBUG_DETAIL, log_buf);
						if (atoi(res_pid) > 0)
							{
							/* if app running */
							kill(atoi(res_pid), SIGUSR1);
							/* kill(atoi(res_pid), SIGKILL); */ 
#if 0
							util_sleep(0, 50);
							if(kill(atoi(res_pid), 0) == -1)
								{
								if(errno == ESRCH)
									;
								else
									(void) kill((pid_t)pidToKill, SIGKILL);
								}	
							else
								(void) kill((pid_t)pidToKill, SIGKILL);
#endif
							}
						/* kill app here */
						return;
						}
					}/*find resource id from shared memory*/
				}
			else
				{
				sprintf(log_buf, "DEBUG: Port %d Free, but no Dynamic Manager", j);
				LogMsg("get_free_port", ISP_DEBUG_DETAIL, log_buf);
				continue;
				}
			}
		} /* strcmp */
	} /* for */
/* no resource found */
return;
} /* get_free_port */
/*---------------------------------------------------------------
This routine set the access process id variable.
---------------------------------------------------------------*/
int set_access_pid()
{
FILE    *fin;                   /* file pointer for the ps pipe */
int     i;
char    buf[BUFSIZE];
char	ps1[] = "ps -ef";
char	ModuleName[]="set_access_pid";
char	userid[50];
int	pid;

if((fin = popen(ps1, "r")) == NULL)
        {                               /* open the process table */
	sprintf(log_buf, ISP_EOPEN_PIPE, "Can't get access pid.", ps1, errno);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (-1);
        }
fgets(buf, sizeof buf, fin);    /* strip of the header */
                                /* get the access proc_id */
i = 0;
while (fgets(buf, sizeof buf, fin) != NULL)
        {
        if(strstr(buf, " access") != NULL)
                {
		sscanf(buf, "%s %d", userid, &pid);
		access_pid = pid;
                pclose(fin);     /* close popen to avoid defunct process */

                return(1);
                }
        }
pclose(fin);                    /* close popen to avoid defunct process */
return(0);
} /* set_access_pid */
/*----------------------------------------------------------------
update_dyn_mgr_appl():
-----------------------------------------------------------------*/
static	int 	update_dyn_mgr_appl(res, pid, pgm_name, dnis)
char	*res;
int	pid;
char	*pgm_name;
char	*dnis;
{
static	char	ModuleName[] = "update_dyn_mgr_appl";
register	int	i;
char	res_str[50];
char	did[50];
char	app[256];

sprintf(app, "%s", pgm_name);
sprintf(did, "%s", dnis);
sprintf(res_str, "%s", res);
for(i=0; i< tran_proc_num; i++)
	{			/* which application is killed? */
	if(pid == appl_pid[i])
		{	
		/* change the name of application of dynamic manager */
		(void) update_application(i, i, app);
		/* reset application setting */
		/* update application name in shmem and change status to busy */
		appl_stat_arry[i] = 1;
/*		(void)write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_BUSY); */
		if((object == TEL) && (strcmp(resource[i].res_state,"STATIC")==0) && (strcmp(resource[i].res_type,"ISDN")==0))
					;
		else
			(void)application_instance_manager(ISP_ADD_INSTANCE, app, res_str);
		update_DNIS(i, did);
		return (0);
		}
	}
sprintf(log_buf, "Unable to get process id of dynamic manager = %d, resource = %s in shared memory", pid, res);
LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
return (-1);
} /* update_dyn_mgr_appl */
/*-----------------------------------------------------------------
update_DNIS(): update the application into shared memory
------------------------------------------------------------------*/
int	update_DNIS(int shm_index, char *did)
{
static	char	ModuleName[] = "update_DNIS";
char	dnis[MAX_PROGRAM];
char	*ptr, *ptr1;

if ((int)strlen(did) > fld_siz[APPL_FIELD6-1])
	{
	/* don't update did */
	return (0);
	}
sprintf(dnis, "%s", did);
ptr = tran_tabl_ptr;
ptr += (shm_index*SHMEM_REC_LENGTH);
/* position the pointer to the field */
ptr += vec[APPL_FIELD6-1];			/* application start index */
ptr1 = ptr;
(void) memset(ptr1, ' ', fld_siz[APPL_FIELD6-1]);
ptr += (fld_siz[APPL_FIELD6-1] - strlen(dnis));
(void) memcpy(ptr, dnis, strlen(dnis));
return (0);
} /* update_DNIS */

/*---------------------------------------------------------------------------
reevaluate_port_state() Check to see if port needs to turned ON or OFF. 
If the port needs to be turned off and it is in IDLE state the dynamic manager
will be killed. 
-----------------------------------------------------------------------------*/
reevaluate_port_state()
{
int	i, portState;
char	failureReason[256];
char	status_str[6], pid_str[7];
int	pidToKill = -1;

for(i = 0; i< tran_proc_num; i++)
	{
	portActive(i,&portState,failureReason);
	(void)read_fld(tran_tabl_ptr, i, APPL_STATUS, status_str);     
	if(portState == 0)
		{
		/* Port should be OFF */
		if(strcmp(resource[i].res_usage, RESERVE_PORT) == 0)
			write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_CHNOFF);
		else if(atoi(status_str) == STATUS_IDLE)
			{
			(void)read_fld(tran_tabl_ptr, i, APPL_PID, pid_str);
			sscanf(pid_str,"%d", &pidToKill);
			if(pidToKill != 0)
				(void)kill((pid_t)pidToKill, SIGTERM);
			}
		else
			write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_CHNOFF);
		}
	else
		{	/* port should be ON */
		if(strcmp(resource[i].res_usage, RESERVE_PORT) == 0)
			write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_OFF);
		else if(atoi(status_str) == STATUS_CHNOFF)
			{
			//sprintf(log_buf, " STATUS_INIT (4), port %d", i);
	//	LogMsg("reevaluate_port", ISP_DEBUG_NORMAL, log_buf);
			write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_INIT);
			}
		}
	} /* End for */	
return(0);
}
/*-----------------------------------------------------------------------------
checkAlarmHandlerFile() : Check to see if Alarm handler has updated the
file. If the T1/E1 is down the turn the ports off otherwise turn them on.
The file updated is Alarm.dat.
-----------------------------------------------------------------------------*/
checkAlarmHandlerFile()
{
char	alarm_file[128];
char	record[128];
char	fieldName[128];
char	tmpbuf1[10], tmpbuf2[10];
int	i, status;
FILE	*fp;
static	time_t	lastModifiedTime = (time_t)0;
struct  stat    file_stat;

sprintf(alarm_file, "%s/%s/%s/%s", isp_base,TELECOM_DIR,TABLE_DIR,
							"Alarm_Handler.dat");

if(access(alarm_file, F_OK) != 0)
	{
	return(0);
	}

#if 0
if (stat(alarm_file, &file_stat) == 0)
{
	/* check if last modified time is changed */
	if (file_stat.st_mtime == lastModifiedTime)
	{
		return (0);
	}
	else
	{
		lastModifiedTime = file_stat.st_mtime;
	}
} /* stat */
#endif
/* Here we want to open the file only if it has changed */
if ((fp=fopen(alarm_file, "r")) == NULL)
	{
	sprintf(log_buf, ISP_EOPEN_FILE, alarm_file, errno);
	LogMsg("checkAlarmHandlerFile", ISP_DEBUG_NORMAL, log_buf);
	return (ISP_FAIL);
	}
	/* If we open the file we should put it in the structure. */
i = 0;
while (fgets(record, sizeof(record), fp) != NULL)
	{
	sscanf(record, "%[^|]|%[^|]|%s",tmpbuf1,tmpbuf2,alarmStatus[i].status);
	sscanf(tmpbuf1, "%d", &alarmStatus[i].startPort);
	sscanf(tmpbuf2, "%d", &alarmStatus[i].endPort);
	alarmStatus[i].startPort--;/* to accomodate counting starting from 0 */
	alarmStatus[i].endPort--;
	if(strcmp(alarmStatus[i].status, "OFF") == 0)
		status = 1;		/* port is OFF */
	if(strcmp(alarmStatus[i].status, "ON") == 0)
		status = 0;		/* port is ON */
	if(alarmStatus[i].startPort < tran_proc_num)
		checkAndSetPortStatus(alarmStatus[i].startPort, alarmStatus[i].endPort, status);
	else
		break;
	i++;
	}
fclose(fp);
return(0);
}

checkAndSetPortStatus(int startPort, int endPort, int status)
{
int	i;
char	status_str[10];

if(status == 1)		/* OFF, Red alarm */
	{
	for(i = startPort; i<= endPort; i++)
		write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_CHNOFF);
	}
if(status == 0)		/* ON, Red OK alarm */
	{
	for(i = startPort; i<= endPort; i++)
		{
		(void)read_fld(tran_tabl_ptr,i,APPL_STATUS,status_str);
		if(atoi(status_str) == STATUS_CHNOFF)
			{
			if(strcmp(resource[i].res_usage, RESERVE_PORT) == 0)
				write_fld(tran_tabl_ptr, i, APPL_STATUS, STATUS_OFF);
			}
		}
	}
return(0);
}
/*-----------------------------------------------------------------------------
StartResourceMgr() : start ResourceMgr 
-----------------------------------------------------------------------------*/
static int	StartResourceMgr()
{
	int	ret;
	char	ResourceMgr_name[64];
	char	ResourceMgr_path[256];
	char	ModuleName[]="StartResMgr";

	sprintf(ResourceMgr_path, "%s/%s", global_exec_path, "ResourceMgr");
	sprintf(ResourceMgr_name, "%s", "ResourceMgr");

	if ((resmgr_pid = fork()) == 0)
	{
		ret = execl(ResourceMgr_path, ResourceMgr_name, NULL);
		if (ret == -1)
		{
			sprintf(log_buf, 
			"Failed to start ResourceMgr <%s>. errno=%d.",
			 ResourceMgr_path, errno);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 			check_and_send_snmp_trap(3039, log_buf, SNMP_Group_Id);
		}
		exit (0);
	}

	sprintf(log_buf, "ResourceMgr started. pid=%d.", resmgr_pid);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (0);
} 

/*-----------------------------------------------------------------------------
StartOCSMgr() : start OCSMgr 
-----------------------------------------------------------------------------*/
static int	StartOCSMgr()
{
	int	ret;
	char	process_name[64];
	char	process_path[256];
	char	dir_path[256];
	char	ModuleName[]="StartOCSMgr";

	sprintf(dir_path, "%s", exec_path);
	sprintf(process_path, "%s/%s", dir_path,"OCSMgr");
	sprintf(process_name, "%s", "OCSMgr");

	if ((OCSMgr_pid = fork()) == 0)
	{
		ret = execl(process_path, process_name, NULL);
		if (ret == -1)
		{
			sprintf(log_buf, 
			"Failed to start OCSMgr <%s>. errno=%d.",
			 process_path, errno);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 			check_and_send_snmp_trap(3039, log_buf, SNMP_Group_Id);
		}
		exit (0);
	}

	sprintf(log_buf, "OCSMgr started. pid=%d.", OCSMgr_pid);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (0);
}
/*-----------------------------------------------------------------------------
StartArcGDynMgr() : start ArcGDynMgr 
-----------------------------------------------------------------------------*/
static int	StartArcGDynMgr()
{
	int	ret;
	char	process_name[64];
	char	process_path[256];
	char	dir_path[256];
	char	resources[10];
	char	ModuleName[]="StartArcGDynMgr";

	sprintf(dir_path, "%s", exec_path);
	sprintf(process_path, "%s/%s", dir_path,"ArcGDynMgr");
	sprintf(process_name, "%s", "ArcGDynMgr");
	sprintf(resources, "%d", Licensed_Resources);

	if ((ArcGDynMgr_pid = fork()) == 0)
	{
		//ret = execl(process_path, process_name, NULL);
		ret = execl(process_path, process_name, resources, (char *) 0);
		if (ret == -1)
		{
			sprintf(log_buf, "Failed to start ArcGDynMgr <%s>. errno=%d.",
			 process_path, errno);
			LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
 			check_and_send_snmp_trap(3039, log_buf, SNMP_Group_Id);
		}
		exit (0);
	}

	sprintf(log_buf, "ArcGDynMgr started. pid=%d.", ArcGDynMgr_pid);
	LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
	return (0);
}
/*---------------------------------------------------------------------------
This routine will check if the resource of desired type is available.
Return the port is available or -1 if not.
-------------------------------------------------------------------------*/
get_available_port(requester, available_port, token1)
int	requester;
int	*available_port;
char	*token1;
{
register	int	j, k;
int	app_pid;
char	res_id[10];
char	res_pid[10];
char	status_str[10];
char	program_name[50];

*available_port = -1;

/* find first free port of any usage */
for(j=0; j <tot_resources; j++)
	{
	/* if available port is requetser - skip */
	if (atoi(resource[j].res_no) == requester)
			continue;
	if (strcmp(resource[j].res_usage, token1) == 0)
		{
		if(res_status[atoi(resource[j].res_no)].status == FREE)
			{
			read_fld(tran_tabl_ptr,j,APPL_STATUS,status_str);
#ifdef DEBUG
			read_fld(tran_tabl_ptr, j, APPL_PID, res_pid);     
			read_fld(tran_tabl_ptr, j, APPL_NAME, program_name);     
			sprintf(log_buf, "DATA: Free port %d, status = %s pid = %s appl = %s", j, status_str, res_pid, program_name);
			LogMsg("get_free_port", ISP_DEBUG_DETAIL, log_buf);
#endif
			if((atoi(status_str) == STATUS_IDLE)||(atoi(status_str) == STATUS_OFF))
				{ /* dynamic manager as well as reserved */	
				*available_port = atoi(resource[j].res_no);
				for(k=0; k<tot_resources; k++)
					{
					/* search resource in shared memory */
					(void)read_fld(tran_tabl_ptr, k, APPL_RESOURCE, res_id);     
					if(atoi(res_id) ==  atoi(resource[j].res_no))
						{
						read_fld(tran_tabl_ptr, k, APPL_PID, res_pid);     
						/* make the port free */
						sprintf(log_buf, "DEBUG: killing dynamic manager = %s", res_pid);
						LogMsg("get_free_port", ISP_DEBUG_DETAIL, log_buf);
						if(atoi(res_pid) > 0)
							{ /* if app running */
							kill(atoi(res_pid), SIGUSR1); 
							
							}
						/* kill app here */
						return;
						}
					}/*find resource id from shared memory*/
				}
			else
				{
				sprintf(log_buf, "DEBUG: Port %d Free, but no Dynamic Manager", j);
				LogMsg("get_free_port",ISP_DEBUG_DETAIL,log_buf);
				continue;
				}
			}
		} /* strcmp */
	} /* for */
/* no resource found */
return;
}

/*---------------------------------------------------------------------------- 
This function checks the mac address of the machine, then looks for and
counts the requested feature. If the feature is not found, and turnkey_allowed 
is set to 1, the then "TURN" is appended to the requested feature and a check 
is done to see if that feature is licensed. If so, the turkey_found is set to
1 and the function returns 0 (success).
----------------------------------------------------------------------------*/
static int arcValidLicense(feature_requested, turnkey_allowed, turnkey_found, feature_count, msg)
char * 	feature_requested;
int 	turnkey_allowed;
int  *	turnkey_found;
int  * 	feature_count;
char * 	msg;
	
{
#if 0
	int rc;
	int count, mac_tries;
	char feature[64];
	char err_msg[512];

/* 4/10/2001 gpw Start of variables added for checking license start date */
	int year, month, day;
	long now;
	long earliest_date;
	struct tm  start_date;
	char start_feature[]="TEL_START";
/* 4/5/2001 gpw End of variables added for checking license start date */

	/* Initialize return values */
	*turnkey_found = 0;
	*feature_count = 0;
	strcpy(msg,""); 

	strcpy(feature,feature_requested);
	rc = lic_get_license(feature, err_msg);
	switch(rc)
	{
	case 0:
		strcpy(msg,"License granted (%s).");
		break;
	case -1:
		if (!turnkey_allowed)
		{
			strcpy(msg, err_msg);
			return(-1);
		}
		sprintf(feature,"%sTURN",feature_requested);
		rc = lic_get_license(feature, err_msg);
		if (rc == 0)
		{
			sprintf(msg,"Turnkey license granted (%s).", feature);
			*turnkey_found = 1;
		}
		else
		{
			sprintf(msg,"Failed to get license (%s).", 
							feature_requested);
			return(-1);
		}
		break;
	default:
		sprintf(msg,"Unknown license return code %d.", rc);
		return(-1);
	}

/* 4/10/2001 gpw Start of new code added for checking license start date */
	rc = lic_get_license(start_feature, err_msg);
	if (rc != 0)
	{
		strcpy(msg, err_msg);
		return(-1);
	}
	rc = lic_get_feature_count_as_yymmdd(start_feature, 
					&year, &month, &day, err_msg);
	fflush(stdout);
	if (rc != 0)
	{
		strcpy(msg, err_msg);
		return(-1);
	}

	/* Convert the start date feature's elements to tics */
	start_date.tm_sec=0;
	start_date.tm_min=0;
	start_date.tm_hour=0;
	start_date.tm_mday=day;
	start_date.tm_mon=month-1;
	start_date.tm_year=year-1900;
	earliest_date=mktime(&start_date);
	
	time(&now);
	if (now < earliest_date)
	{
		strcpy(msg,"License failure: premature usage");
		return(-1);
	}	
/* 4/10/2001 gpw End of new code added for checking license start date */

	rc = lic_count_licenses(feature, &count, err_msg);
	if (rc == -1)
	{
		strcpy(msg,err_msg);
	 	return(-1);
	}
#endif

	*turnkey_found = 0;
	*feature_count = 192;
	strcpy(msg,""); 
	return(0);
}
/*-----------------------------------------------------------------------------
This routine will checjk the existance of DynMgr.port file. If the file exists
it will assume that the dynamic manager on that port is hung and it will 
kill that dynamic manager.
----------------------------------------------------------------------------*/
look_for_dynmgr_file()
{
static	char	ModuleName[] = "look_for_dynmgr_file";
int	i;
char	filename[15];
char	pid_str[10];
int	pidToKill = -1;

for(i = 0; i < tot_resources; i++)
	{
	sprintf(filename, "/tmp/%s.%d", "DynMgr", i);
	if(access(filename, F_OK) == 0)
		{
		(void)read_fld(tran_tabl_ptr, i, APPL_PID, pid_str);     
		sprintf(log_buf,
		"File <%s> exists. Killing dyn manager pid <%s>.",
				filename, pid_str);
		LogMsg(ModuleName,ISP_DEBUG_NORMAL, log_buf);
		sscanf(pid_str, "%d", &pidToKill);
		if(pidToKill != 0)
			(void) kill((pid_t)pidToKill, SIGKILL);
		}
	}
return(0);
}


/*----------------------------------------------------------------------------
This routine loads the appref & pgmref tables from the license file.
----------------------------------------------------------------------------*/
int load_appref_pgmref_from_license()
{
	int rc;
	int fcount=0;
	FILE *fp;
	char	opcode[50];
	char	dummy[128];
	char	feature[128];
	char 	inputbuf[256];
	char 	license_file[256];
	char 	ModuleName[]="load_appref_pgmref";
	int 	dummy2;

	tot_apprefs = 0;
	tot_pgmrefs = 0;

	rc = get_license_file_name(license_file, log_buf); 
	if (rc != 0)
	{
		LogMsg(ModuleName,ISP_DEBUG_NORMAL, log_buf);
		return(ISP_FAIL);
	}

	if ((fp = fopen(license_file, "r")) == NULL)
        {
        	sprintf(log_buf, "Unable to open %s for reading. errno=%d",
		license_file, errno);
		LogMsg(ModuleName,ISP_DEBUG_NORMAL, log_buf);
		return(ISP_FAIL);
        }

	while(fgets(inputbuf, sizeof(inputbuf), fp))
	{
		opcode[0] = '\0';
		feature[0] = '\0';
      		inputbuf[(int)strlen(inputbuf)-1] = '\0';
		if (strlen(inputbuf) == 0) continue;
		if (    inputbuf[0] == '\t' || 
			inputbuf[0] == '#'  ||
			inputbuf[0] == ' ') continue;

		sscanf(inputbuf,"%s %s %s %s %s %d", 
		opcode, feature, dummy, dummy, dummy, &fcount);
		if ( strcmp(opcode, "FEATURE") != 0 ) continue;
		if ( feature[0] == 'T' && feature[1] == 'K')
		{
/* new code */
//		rc = lic_get_license(feature,log_buf); 
		rc = 0;
		if (rc != 0)
		{
			sprintf(log_buf,"Cannot load <%s>. License violation.",
					&feature[2]);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
			continue;
		}		
/* end code */
			sprintf(appref[tot_apprefs].appl_grp_name, "%s", 
					&feature[2]);
			sprintf(appref[tot_apprefs].acct_code, "%s", 
					&feature[2]);
			appref[tot_apprefs].max_instance = fcount;
			tot_apprefs++;
			sprintf(pgmref[tot_pgmrefs].program_name, "%s", 
					&feature[2]);
			sprintf(pgmref[tot_pgmrefs].appl_grp_name, "%s", 
					&feature[2]);
			tot_pgmrefs++;
		}
   	} 
	pclose(fp);
	return(ISP_SUCCESS);
} 


/*----------------------------------------------------------------------------
Get the full pathname of the license file.
Note: This function is a duplicate of an internal function used by the
licensing mechanism. I had to include it since I could not link with the 
original.  gpw 7/26/99
----------------------------------------------------------------------------*/	
static int get_license_file_name(license_file, err_msg)
char *license_file;
char *err_msg;
{
	static int got_file_already=0;
	static char hold_license_file[256];
	char *ispbase;
	char base_env_var[]="ISPBASE";

	if (got_file_already)
	{
		strcpy(license_file, hold_license_file);
		strcpy(err_msg,"");
		return(0);
	}
	
	if ((ispbase = getenv(base_env_var)) != NULL)
	{
		got_file_already=1;
		sprintf(hold_license_file,"%s/Global/Tables/license.dat", 
					ispbase);
		strcpy(license_file, hold_license_file);
#ifdef DEBUG
		fprintf(stdout,"The file is '%s'\n", license_file); fflush(stdout);
#endif
		strcpy(err_msg,"");
		return(0);
	}
	else
	{
		sprintf(err_msg,"Unable to get evironment variable %s.",
			base_env_var); 
		return(-1);
	}
}
/*---------------------------------------------------------------------------
check to see if the application is valid turnkey application
----------------------------------------------------------------------------*/
checkValidTurnkeyApp()
{
static	char	ModuleName[] = "checkValidTurnkeyApp";
static	int	counter=0;
int	handshakeArray[MAX_PROCS];
int	statusArray[MAX_PROCS];
char	program_name[256];
int	i;

counter++;
if(counter > 3)
	{
	counter = 0;
	(void)read_arry(tran_tabl_ptr, APPL_STATUS, statusArray);
	(void)read_arry(tran_tabl_ptr, APPL_FIELD5, handshakeArray);
	for(i=0; i<tran_proc_num; i++)
		{

/*	fprintf(stdout,"gpwDEBUG: slot=%d status=%d handshake=%d\n", 
		i, statusArray[i], handshakeArray[i]); fflush(stdout);  */
		if((statusArray[i] == STATUS_BUSY) && (handshakeArray[i] == 1))
			{
			if(appl_pid[i] != 0)
				{
				(void)read_fld(tran_tabl_ptr, i, APPL_NAME, program_name);     
				(void) kill((pid_t)appl_pid[i], SIGTERM);
				sprintf(log_buf, "Killing application <%s> (pid %d) for license violation.", 
				program_name, appl_pid[i]);
				LogMsg(ModuleName, ISP_DEBUG_NORMAL, log_buf);
				}
			}
		}
	}
return(0);
}

void convertStarToUnixPatternMatch(char *parmStarString, char *parmResultString)
{
    int i;
    char buf[10];

    memset(parmResultString, 0, sizeof(parmResultString));

    for(i=0; i<strlen(parmStarString); i++)
    {
        if(parmStarString[i] == '*')
            sprintf(buf, "%s", "[0-9]*");
        else
            sprintf(buf, "%c", parmStarString[i]);

        strcat(parmResultString, buf);
    }

    sprintf(buf, "%s", "$");
    strcat(parmResultString, buf);

    return;
}

/*------------------------------------------------------------------------------
stringMatch(): Matches the given string based on the pattern.

Input:

        iPattern                        The pattern that needs to be matched
        iString                         The string containing the pattern

Output:

        None

Return Codes:

        0                                       String does not match pattern
        1                                       String matches pattern.

Notes:
        1. If either the pattern or the string are empty, a mismatch is returned
.
------------------------------------------------------------------------------*/
int stringMatch(char *iPattern, char *iString)
{
        static char     mod[] = "stringMatch";
	int		rc;
	regex_t 	preg;

	if(iPattern[0] == '\0' || iString[0] == '\0')
	{
		return(0);
	}

	if(regcomp(&preg, iPattern, 0) != 0)
	{
		return(0);
	}

	if(regexec(&preg, iString, 0, 0, 0) != 0)
	{
		rc = 0;
	}
	else
	{
		rc = 1;
	}

	regfree(&preg);

        return(rc);
} /* END stringMatch() */

/*----------------------------------------------------------------------------
This function gets the value of the verbose logging parameter in the 
Global configuration table.
----------------------------------------------------------------------------*/
getLogparmValue(char *report_mode)
{
FILE	*fp;
char	str[80];
int	i;
char	*ptr, *BaseDir;
char	file_name[80];

BaseDir=(char *)getenv("ISPBASE");

sprintf(file_name,"%s/Global/.Global.cfg", BaseDir);

if((fp=fopen(file_name, "r")) == NULL)
	{
	return(-1);
	}

while(fgets(str, 80, fp) != NULL)
	{
	if(str[0] == '[')
		continue;
	if(str[0] == ' ')
		continue;
	if(str[0] == '\n')
		continue;
	if(strncmp(str, "LOG_REPORT_VERBOSE", 18) == 0)
		{
 		if((ptr = strchr(str, '=')) != NULL)
                        {
			ptr++;
			report_mode[0] = '\0';
			strcpy(report_mode, ptr);
			report_mode[strlen(report_mode) - 1] = '\0';
			}
		}
	}
return(0);
}
/*---------------------------------------------------------------------------
Look for DNIS match in the scheduling table.
----------------------------------------------------------------------------*/
lookForDnisMatch(int match_rule, int type, char *dnis, char *ani, 
						struct	schedule *record)
{
int	i;
char	pattern[50];
int		ret;

for (i=0; i < tot_schedules; i++)
	{
	if(type == 1)
		{
		sprintf(pattern, "%s", schedule[i].destination);
		if(strcmp(pattern, dnis) == 0)
			ret = 1;
		else
			ret = 0;
		}
	else
		{
		convertStarToUnixPatternMatch(schedule[i].destination, pattern);
		ret = stringMatch(pattern, dnis);
		}
	if(ret == 1)
		{
		/* token 1 found  or wild token 1 */
		/* find application from token1 only */
		if((match_rule ==  TOKEN1_APPL) || (match_rule == STATIC_APPL))
			{
			/* mahesh new change to allow mutiple dnis */
			if (check_date_time_rule("RES", schedule[i].program, schedule[i].start_date, schedule[i].stop_date, schedule[i].start_time, schedule[i].stop_time, schedule[i].rule) != ISP_SUCCESS)
				{
				/* if date and time rule failed find */
				/* next match */
				continue;
				}
			sprintf(record->srvtype, "%s", schedule[i].srvtype);
			sprintf(record->machine, "%s", schedule[i].machine);
			sprintf(record->destination, "%s", schedule[i].destination);
			sprintf(record->origination, "%s", schedule[i].origination);
			record->priority = schedule[i].priority;
			record->rule     = schedule[i].rule;
			sprintf(record->start_date,"%s",schedule[i].start_date);
			sprintf(record->stop_date, "%s", schedule[i].stop_date);
			sprintf(record->start_time,"%s",schedule[i].start_time);
			sprintf(record->stop_time, "%s", schedule[i].stop_time);
			sprintf(record->program, "%s", schedule[i].program);
			sprintf(record->acct_code, "%s", schedule[i].acct_code);
			sprintf(record->appl_grp_name, "%s", schedule[i].appl_grp_name);
			record->max_instance = schedule[i].max_instance;
			return (ISP_SUCCESS);
			}
		/* find application from both token */
		if (match_rule == TOKEN_APPL)
			{
			/* token 2 found */
			if (strcmp(schedule[i].origination, ani) == 0)
				{
				if (check_date_time_rule("RES", schedule[i].program, schedule[i].start_date, schedule[i].stop_date, schedule[i].start_time, schedule[i].stop_time, schedule[i].rule) != ISP_SUCCESS)
					{
					/* if date and time rule */
					/* failed find next match */
					continue;
					}
				sprintf(record->srvtype, "%s", schedule[i].srvtype);
				sprintf(record->machine, "%s", schedule[i].machine);
				sprintf(record->destination, "%s", schedule[i].destination);
				sprintf(record->origination, "%s", schedule[i].origination);
				record->priority = schedule[i].priority;
				record->rule     = schedule[i].rule;
				sprintf(record->start_date, "%s", schedule[i].start_date);
				sprintf(record->stop_date, "%s", schedule[i].stop_date);
				sprintf(record->start_time, "%s", schedule[i].start_time);
				sprintf(record->stop_time, "%s", schedule[i].stop_time);
				sprintf(record->program, "%s", schedule[i].program);
				sprintf(record->acct_code, "%s", schedule[i].acct_code);
				sprintf(record->appl_grp_name, "%s", schedule[i].appl_grp_name);
				record->max_instance = schedule[i].max_instance;
				return (ISP_SUCCESS);
				}
			}
		}
	} /* for rule token1 and token */
return(ISP_FAIL);
}
/*--------------------------------------------------------------
This routine gets the value of desired field from data record.
---------------------------------------------------------------*/
int utlGetField(buffer, fld_num, field)
const   char    buffer[];               /* data record */
int     fld_num;                        /* field # in the buffer */
char    field[];                        /* buffer to fill with the field name */
{
register        int     i;
int     fld_len = 0;                    /* field length */
int     state = OUT;                    /* current state IN or OUT */
int     wc = 0;                         /* word count */

field[0] = '\0';
if( fld_num < 0)
	{
        return (-1);
	}

for(i=0; i < (int)strlen(buffer); i++) 
        {
        if(buffer[i] == ' ' || buffer[i] == '\n')
                {
                state = OUT;
                if(buffer[i] == ' ' && buffer[i-1] == ' ')
                        ++wc;
                }
        else if (state == OUT)
                {
                state = IN;
                ++wc;
                }
        if (fld_num == wc && state == IN)
		{
                field[fld_len++] = buffer[i];
		}
        if (fld_num == wc && state == OUT)
		{
                break;
		}
        } /* for */

if (fld_len > 0)                                /*  for last field */
        {
        field[fld_len] = '\0';
        while(field[0] == ' ')
                {
                for (i=0; field[i] != '\0'; i++)
                        field[i] = field[i+1];
                }
        fld_len = strlen(field);
        return (fld_len);                       /* return field length*/
        }
return (-1);                                    /* return error */
} /* utlGetField() */

int	readRulesFromCfg()
{
	char mod[] = {"readRulesFromCfg"};
	FILE	*fp;
	char	buf[256];
	int 	rc;
	char	*pChar;
	int 	sectionStarted = 0;
	int 	lenBufRead;
	int 	i;
	char 	huntGroupCfgFileName[256];
	int 	defaultSectionRule = RULE_FIRST_AVAILABLE;

	sprintf(huntGroupCfgFileName, "%s/%s", table_path, HUNT_GROUP_CFG);
	gMaxSections = 0;
	memset(gGivePortRule, 0, sizeof(struct GivePortRule) * MAX_NUM_SECTIONS);

	fp = fopen(huntGroupCfgFileName, "r");
	if(fp == NULL)
	{
		sprintf(log_buf,"Failed to open file %s.errno=%d.",
			huntGroupCfgFileName, errno);
		LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
		return(-1);
	}

	while(fgets(buf, sizeof(buf), fp) != NULL)
	{
		if(buf[0] == '[')
		{
			gMaxSections++;

			gGivePortRule[gMaxSections-1].rule = -1;
			pChar = (char *)strchr(buf, ']');
			*pChar = '\0';
			sprintf(gGivePortRule[gMaxSections-1].section, "%s", &buf[1]);
			gGivePortRule[gMaxSections-1].lastPortGiven = -1;

			sectionStarted = 1;
		}
		else if(sectionStarted == 1)
		{
			lenBufRead = strlen(buf);
			if(buf[lenBufRead-1] == '\n')
			{
				buf[lenBufRead-1] = '\0';
				lenBufRead--;
			}
			if(lenBufRead > 0)
			{
				sectionStarted = 0;
		
				for(i=0; i<lenBufRead; i++)
					buf[i] = toupper(buf[i]);	

				if(strcmp(buf, "FIRSTAVAILABLE") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_FIRST_AVAILABLE;
				}
				else if(strcmp(buf, "ASCENDING") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_ASCENDING;
				}
				else if(strcmp(buf, "ASCENDINGEVEN") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_ASCENDING_EVEN;
				}
				else if(strcmp(buf, "ASCENDINGODD") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_ASCENDING_ODD;
				}
				else if(strcmp(buf, "DESCENDING") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_DESCENDING;
				}
				else if(strcmp(buf, "DESCENDINGEVEN") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_DESCENDING_EVEN;
				}
				else if(strcmp(buf, "DESCENDINGODD") == 0)
				{
					gGivePortRule[gMaxSections-1].rule = RULE_DESCENDING_ODD;
				}
				else
				{
					sprintf(log_buf, "Invalid rule <%s> for section <%s>. "
						"Possible values are FirstAvailable, Ascending, "
						"Descending, AscendingEven, DescendingEven, "
						"AscendingOdd, DescendingOdd. Ignoring.", buf, 
						gGivePortRule[gMaxSections-1].section); 
					LogMsg(mod, ISP_DEBUG_NORMAL, log_buf);
					sectionStarted = 1;
				}

				if(strcmp(gGivePortRule[gMaxSections-1].section, "Default")==0)
				{
					defaultSectionRule = gGivePortRule[gMaxSections-1].rule;
				}
			}
		}
	}

	fclose(fp);

	for(i=0; i<gMaxSections; i++)
	{
		if(gGivePortRule[i].rule == -1)
		{
			gGivePortRule[i].rule = defaultSectionRule;
		}
	}

	return(0);
}

int checkRuleAndGetPort(int lastGiven, int descending, int even, int odd,
	int *port, char *usage_type)
{
	int start, end, step, i;

	start = 0;
	end = tot_resources - 1;
	step = 1;
	*port = -1;

	if(even == 1)
	{
		step = 2;
		if(end%2 != 0)
			end--;

		if(lastGiven == -1)
		{
			if(descending == 1)
				lastGiven = 0;
			else
				lastGiven = -2;
		}
	}
	else if(odd == 1)
	{
		start = 1;
		step = 2;
		if(end%2 == 0)
			end--;

		if(lastGiven == -1)
		{
			if(descending == 1)
				lastGiven = 1;
		}
	}

	if(descending == 1)
	{
		for(i=lastGiven-step; i>=start; i=i-step)
		{
			if (strcmp(resource[i].res_usage, usage_type) == 0)
			{
				if(checkIfFree(i) == 0)
				{
					*port = i;
					return(0);
				}
			}
		}
	
		for(i=end; i>=lastGiven; i=i-step)
		{
			if (strcmp(resource[i].res_usage, usage_type) == 0)
			{
				if(checkIfFree(i) == 0)
				{
					*port = i;
					return(0);
				}
			}
		}
	
		return(-1);
	}
	else
	{
		for(i=lastGiven+step; i<=end; i=i+step)
		{
			if (strcmp(resource[i].res_usage, usage_type) == 0)
			{
				if(checkIfFree(i) == 0)
				{
					*port = i;
					return(0);
				}
			}
		}
	
		for(i=start; i<=lastGiven; i=i+step)
		{
			if (strcmp(resource[i].res_usage, usage_type) == 0)
			{
				if(checkIfFree(i) == 0)
				{
					*port = i;
					return(0);
				}
			}
		}
		return(-1);
	}
	return(-1);
}
	
int checkIfFree(int zPort)
{
	char mod[]={"checkIfFree"};
	int k;
	char status_str[10];
	char res_id[10];
	char res_pid[10];

	if(res_status[atoi(resource[zPort].res_no)].status == FREE)
	{
		read_fld(tran_tabl_ptr,zPort,APPL_STATUS,status_str);
		if((atoi(status_str) == STATUS_IDLE)||(atoi(status_str) == STATUS_OFF))
		{
			for(k=0; k<tot_resources; k++)
			{
				/* search resource in shared memory */
				(void)read_fld(tran_tabl_ptr, k, APPL_RESOURCE, res_id);     
				if(atoi(res_id) ==  atoi(resource[zPort].res_no))
				{
					read_fld(tran_tabl_ptr, k, APPL_PID, res_pid);     
					/* make the port free */
					sprintf(log_buf, "DEBUG: killing dynamic manager = %s", 
						res_pid);
					LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
					if(atoi(res_pid) > 0)
					{ /* if app running */
						kill(atoi(res_pid), SIGUSR1); 
					}
					/* kill app here */
					return(0);
				}
			}
		}
		else
		{
			sprintf(log_buf, "DEBUG: Port %d Free, but no Dynamic Manager", 
				zPort);
			LogMsg(mod, ISP_DEBUG_DETAIL, log_buf);
			return(-1);
		}
	}

	return(-1);
}
