/*---------------------------------------------------------------------------
File:		arcAICommon.c
Author:		Aumtech, Inc.
Update:		10-21-23: 	djb	Created the file.
Purpose:	Contains the ctype functions for the python chatGPT client
		    (ArcAIClient.py) 
		    This includes
		      c_aiLog:                  allows the client to log to the ISP.cur,
		      c_writeResponseToApp:     allows the client to write the 
		                                results to the application fifo, and
		      c_decryptChatGPT_api_key: performs the decryption on the
		                                chatGPT api key.

		     Note: c_aiLog is dependent on the shared
		           libraries libaiISPLog.so and libailoglite.so.  
		           These are built in the 
		           /home/dan/isp2.2/SIPTelecom3.6/Common/aiLog directory.
  ---------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#define MAX_PORTS   128

#define AI_BASE		2600			// defined in TEL_Logmessages.h on source system

#define REPORT_NORMAL 	1
#define REPORT_VERBOSE	2
#define REPORT_DETAIL	128

#define	ERR		0
#define	WARN	1
#define	INFO	2

#define	ENCRYPTION_KEY_MODIFIER	-9

#define	CHAT_API_KEY			"ChatGPT_api_key"

typedef struct 
{
    char responseFifo[128];
    int responseFifoFd;
} Call;

static Call gCall[MAX_PORTS];
char	*gp_decryptedStr;

struct python_MsgToApp
{
    int opcode;         /* Op code */
    int appCallNum;     /* Call # of app instance: 0,1, etc. */
    int appPid;         /* Application pid */
    int appRef;         /* Unique # generated by the API */
    int appPassword;    /* Unique # generated by the DM */
    int returnCode;     /* return code (result) */
    int vendorErrorCode;
    int alternateRetCode;
    char *message;  /* Error or warning message */
} ;

struct MsgToApp
{
    int opcode;         /* Op code */
    int appCallNum;     /* Call # of app instance: 0,1, etc. */
    int appPid;         /* Application pid */
    int appRef;         /* Unique # generated by the API */
    int appPassword;    /* Unique # generated by the DM */
    int returnCode;     /* return code (result) */
    int vendorErrorCode;
    int alternateRetCode;
    char message[224];  /* Error or warning message */
} ;

void c_aiLog (int zLine, char *zFile, int zCall, char *zMod, int zMode, int zMsgId, int zMsgType, char *zMsg)
{
    char        cMsg[512];
    char        cType[16];
    char        cPort[6];

    switch (zMsgType)
    {
        case 0:         // ERR
            sprintf(cType, "ERR: ");
            break;
        case 1:         // WARN
            sprintf(cType, "WARN: ");
            break;
        case 2:         // INFO
            sprintf(cType, "INF: ");
            break;
        default:        // INFO
            sprintf(cType, "INF: ");
            break;
    }
    sprintf(cMsg, "%s[%s, %d]%s", cType, zFile, zLine, zMsg);
    sprintf(cPort, "%d", zCall);

	LogARCMsg(zMod, zMode, cPort, "AI", "ArcAIClient.py", 823732, cMsg);
}

/*--------------------------------------------------------------------
  --------------------------------------------------------------------*/
int c_writeResponseToApp(int zLine, char *zFile, int zCall, char *responseFifoName, struct python_MsgToApp msg)
{
    int rc;
    int port;
    struct MsgToApp lMsg;
	static char mod[]="c_writeResponseToApp";
	char	logMsg[512];

    if ( (responseFifoName[0] == '\0') || ( ! responseFifoName) )
    {
        printf("null fifo name. no worky");
        return(-1);
    }

    if ((rc = open(responseFifoName, O_RDWR | O_NONBLOCK)) < 0)
    {
    	sprintf(logMsg, "Failed to open (%s). [%d, %s]", responseFifoName, errno, strerror(errno));
		c_aiLog (zLine, zFile, zCall, mod, REPORT_NORMAL, AI_BASE, ERR, logMsg);
        return(-1);
    }

    sprintf(gCall[msg.appCallNum].responseFifo, "%s", responseFifoName);
    gCall[msg.appCallNum].responseFifoFd = rc;
    sprintf(logMsg, "Successfully opened(%s) with FD=%d.",
            gCall[msg.appCallNum].responseFifo,
            gCall[msg.appCallNum].responseFifoFd);
	c_aiLog (zLine, zFile, zCall, mod, REPORT_VERBOSE, AI_BASE, INFO, logMsg);

	

    memset((struct MsgToApp *)&lMsg, '\0', sizeof(struct MsgToApp));
    lMsg.opcode = msg.opcode;
    lMsg.appCallNum = msg.appCallNum;
    lMsg.appPid = msg.appPid;
    lMsg.appRef = msg.appRef;
    lMsg.appPassword = msg.appPassword;
    lMsg.returnCode = msg.returnCode;
    lMsg.vendorErrorCode = msg.vendorErrorCode;
    lMsg.alternateRetCode = msg.alternateRetCode;
    sprintf(lMsg.message, "%.*s", 220, msg.message);

#if 0
    printf("[%s, %d]\n", __FILE__, __LINE__);
    printf("[%s, %d] lMsg.message=(%s)\n", __FILE__, __LINE__, lMsg.message);

    printf("opcode:%d\n", lMsg.opcode);
    printf("[%s, %d]\n", __FILE__, __LINE__);
    printf("appCallNum:%d\n", lMsg.appCallNum);
    printf("appPid:%d\n", lMsg.appPid);
    printf("appRef:%d\n", lMsg.appRef);
    printf("appPassword:%d\n", lMsg.appPassword);
    printf("returnCode:%d\n", lMsg.returnCode);
    printf("[%s, %d]\n", __FILE__, __LINE__);
    printf("vendorErrorCode:%d\n", lMsg.vendorErrorCode);
    printf("alternateRetCode:%d\n", lMsg.alternateRetCode);
    printf("message:(%s)\n", lMsg.message);
    printf("[%s, %d]\n", __FILE__, __LINE__);

    printf("[%s, %d] sizeof(msg)=%d\n", __FILE__, __LINE__, sizeof(msg));
    printf("[%s, %d] sizeof(lMsg)=%d\n", __FILE__, __LINE__, sizeof(lMsg));
#endif

    rc = write (gCall[lMsg.appCallNum].responseFifoFd, &lMsg,
                sizeof (struct MsgToApp));
    if (rc == -1)
    {
        sprintf(logMsg, "Failed to write to response [op=%d, rtc=%d] fifo (%d:%s). [%d, %s]",
                    msg.opcode, msg.returnCode, 
                    gCall[msg.appCallNum].responseFifoFd, gCall[msg.appCallNum].responseFifo,
                    errno, strerror(errno));
		c_aiLog (zLine, zFile, zCall, mod, REPORT_NORMAL, AI_BASE, ERR, logMsg);
        return (-1);
    }

    sprintf(logMsg, "fd(%d), %d = write(%s) op:%d,call:%d,ref:%d,pid:%d,rtc:%d,message(%s)",
            gCall[msg.appCallNum].responseFifoFd, rc,
            gCall[msg.appCallNum].responseFifo,
            lMsg.opcode, lMsg.appCallNum, lMsg.appRef,
            lMsg.appPid, lMsg.returnCode, lMsg.message);
	c_aiLog (zLine, zFile, zCall, mod, REPORT_VERBOSE, AI_BASE, INFO, logMsg);

    return(0);

} // END: c_writeResponseToApp()

/*---------------------------------------------------------------------------
  ---------------------------------------------------------------------------*/
int c_decryptChatGPT_api_key(int zLine, char *zFile, int zCall, char *zEncodedStr)
{ 
	static char		mod[]="c_decryptChatGPT_api_key";
	int		rc;
	int		i;
	int		modifier;
	char	tmpStr[256] = "";;
	char	logMsg[512];

    if ( (zEncodedStr[0] == '\0') || ( ! zEncodedStr ) || ( zEncodedStr == (char *)NULL) )
    {
    	sprintf(logMsg, "%s", "Empty string received. Unable to decode.");
		c_aiLog (zLine, zFile, zCall, mod, REPORT_NORMAL, AI_BASE, ERR, logMsg);
		return(-1);
    }

	if ((gp_decryptedStr = (char *)calloc(256, sizeof(char))) == NULL )
	{
    	sprintf(logMsg, "Failed to allocate memory: [%d, %s] Unable to decode api key.", errno, strerror(errno));
		c_aiLog (zLine, zFile, zCall, mod, REPORT_NORMAL, AI_BASE, ERR, logMsg);
		return(-1); 	// null
	}
		
	memset((char *)tmpStr, '\0', sizeof(tmpStr));
	modifier = ENCRYPTION_KEY_MODIFIER * -1;

	i = 0;
	while ( zEncodedStr[i] != '\n' && zEncodedStr[i] != '\0' )
	{
		tmpStr[i] = zEncodedStr[i] + modifier;
		i++;
	}

	if (strlen(tmpStr) > 0)
	{
		sprintf(zEncodedStr, "%s", tmpStr);
    	sprintf(logMsg, "[%d] returning (%s)", __LINE__, zEncodedStr);
		c_aiLog (zLine, zFile, zCall, mod, REPORT_VERBOSE, AI_BASE, INFO, logMsg);
		return(0);
	}
   	sprintf(logMsg, "Failed to decode (%s)..", zEncodedStr);
	c_aiLog (zLine, zFile, zCall, mod, REPORT_NORMAL, AI_BASE, ERR, logMsg);
	return(-1);

} // END: arcDecryptChatGPT_api_key()
