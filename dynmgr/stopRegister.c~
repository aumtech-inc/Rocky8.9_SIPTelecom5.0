/*------------------------------------------------------------------------------
Program Name:	stopRegister
File Name:		stopRegister.c
Purpose:  		Utility to send DMOP_STOPREGISTER command to ArcSipCallMgr.
				ArcSipCallMgr then stops sending REGISTER to remote redirector
				TODO: Write generic utility to send any message to call mgr.
Author:			Aumtech, inc.
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------
Update: 05/09/2008 DDN Created the file
------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/timeb.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <wchar.h>
#include <ctype.h>
#include <sched.h>
#include <iostream>
#include <curses.h>

#include "../include/AppMessages.h"

#define CALL_MANAGER_COUNT 12
#define CALL_MANAGER_FIFO "/tmp/RequestFifo.%d"


unsigned char test_out[] = {
  0x0a, 0x49, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65,
  0x20, 0x6c, 0x6f, 0x67, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6d,
  0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x68, 0x6f, 0x6c,
  0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x73, 0x69, 0x6e, 0x67,
  0x0a, 0x49, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65,
  0x20, 0x6c, 0x6f, 0x67, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x6f, 0x76,
  0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61,
  0x6c, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x73, 0x0a, 0x49, 0x20, 0x77,
  0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x6f, 0x67,
  0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20,
  0x74, 0x68, 0x65, 0x20, 0x79, 0x6f, 0x75, 0x6e, 0x67, 0x20, 0x67, 0x69,
  0x72, 0x6c, 0x73, 0x20, 0x63, 0x72, 0x79, 0x0a, 0x49, 0x20, 0x77, 0x72,
  0x69, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x6f, 0x67, 0x73,
  0x2c, 0x20, 0x49, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x68,
  0x65, 0x20, 0x6c, 0x6f, 0x67, 0x73, 0x0a, 0x0a, 0x00
};


struct myMsgStruct
{
	char details[256];
	struct MsgToDM;
};

struct myMsgStruct msgStruct[100];

#if 0
struct MsgToDM
    {
        int opcode;         /* Op code */
        int appCallNum;     /* Call # of app instance: 0,1, etc. */
        int appPid;         /* Application pid */
        int appRef;         /* Unique # generated by the API */
        int appPassword;    /* Unique # generated by the DM */
        char data[MAX_APP_MESSAGE_DATA];
    };

#endif

int operate(int choice, int callMgr)
{
	char yStrFifo[256];
	int	yFifoFd;
	int rc;

	struct MsgToDM yMsgToDM;

	yMsgToDM.opcode = choice;
	yMsgToDM.appCallNum = callMgr * 48;
	yMsgToDM.appPid = getpid();
	yMsgToDM.appRef = 1;
	yMsgToDM.appPassword = callMgr * 48;
	yMsgToDM.data[0] = 0;

	printf("Sending DMOP_STOPREGISTER to Call Mgr %d.\n", callMgr);

	sprintf(yStrFifo, CALL_MANAGER_FIFO, callMgr);

	if ((yFifoFd = open (yStrFifo, O_RDWR)) < 0)
	{
		printf("Call Mgr %d is not present.\n", callMgr);
		return -1;
	}

	rc = write (yFifoFd, &(yMsgToDM), sizeof(yMsgToDM));
	if(rc < 0)
	{
		printf("Call Mgr %d is not present. errno(%d).\n", callMgr, errno);
		close(yFifoFd);
		return -1;
	}

	printf("Call Mgr %d has been notified.\n", callMgr);
	close(yFifoFd);
	return 0;

}/*END: int operate*/

int getCallMgrId()
{
	char yIntC1;
	int yIntC2;

	printf("Send the message to all call mgrs?[y/n]:\n");

	fflush(stdout);

	scanf("%d", &yIntC1);

	printf("\nEntered '%c'\n", yIntC1);

	if(yIntC1 == 'y' || yIntC1 == 'Y')
	{
		return (-99);
	}

	printf("\nEnter ID of call mgr between 0 and 12.: ");

	scanf("%d", &yIntC2);

	return(yIntC2);

}/*END: int getCallMgrId*/

int main(int argc, char *argv[])
{
	int rc;
	char yStrArgv1[256];

	if(argc > 1)
	{
		sprintf(yStrArgv1, "%s", argv[1]);

		if(strchr(yStrArgv1, '?'))
		{
			printf("\nUtility to send DMOP_STOPREGISTER to all running call managers. Aumtech, 2008.\n");
			printf("Usage: %s\n", argv[0]);
			exit(0);
		}
		else if(strstr(yStrArgv1, "-v") )
		{
			printf("\n%s\nVersion 1.0,  %s %s.\n", argv[0], __DATE__, __TIME__);
			exit(0);
		}
	}

#if 0
	//struct myMsgStruct msgStructX = {"Stop Sending Registration Requests", { DMOP_STOPREGISTER, 0, 0, 0, 0, ""} };

	int yIntChoice1, yIntChoice2;

	printf("Menu:\n");
	printf("1.	Stop Sending Registration Requests from call Managers.\n");
	printf("2.	Exit\n");
	printf("Enter your choice: \n");
	scanf("%d", &yIntChoice1);

	switch(yIntChoice1)
	{
		case 1:
			yIntChoice2 = getCallMgrId();

			if(yIntChoice2 == -99)
			{
				for(int i = 0; i < 12; i++)
				{
					if(operate(DMOP_STOPREGISTER, i) < -1)
					{
						break;
					}
				}
			}
			else
			{
				operate(DMOP_STOPREGISTER, yIntChoice2);
			}
			break;
		case 2:
		default:
			printf("Exiting...\n");
			exit(0);
	}
#endif

	/*Call Manager count is below 12 (for now).*/
	for(int i = 0; i < CALL_MANAGER_COUNT; i++)
	{
		rc = operate(DMOP_STOPREGISTER, i);

		if(rc < 0)
		{
			break;
		}
	}

	printf("\nExiting...\n");

}/*END: main*/
