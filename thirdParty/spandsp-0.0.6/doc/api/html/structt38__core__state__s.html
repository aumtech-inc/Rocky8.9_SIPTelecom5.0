<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spandsp: t38_core_state_s Struct Reference</title>
<link href="css.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>t38_core_state_s Struct Reference</h1><!-- doxytag: class="t38_core_state_s" --><code>#include &lt;<a class="el" href="private_2t38__core_8h-source.html">t38_core.h</a>&gt;</code>
<p>
<a href="structt38__core__state__s-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7c2e9ed2cef3260c57c34eb1c9879bc"></a><!-- doxytag: member="t38_core_state_s::tx_packet_handler" ref="a7c2e9ed2cef3260c57c34eb1c9879bc" args="" -->
t38_tx_packet_handler_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a7c2e9ed2cef3260c57c34eb1c9879bc">tx_packet_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler routine to transmit IFP packets generated by the T.38 protocol engine. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab76bfa8e89b37afb8f6ee97d1e7ff26"></a><!-- doxytag: member="t38_core_state_s::tx_packet_user_data" ref="ab76bfa8e89b37afb8f6ee97d1e7ff26" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ab76bfa8e89b37afb8f6ee97d1e7ff26">tx_packet_user_data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An opaque pointer passed to tx_packet_handler. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7b0e8b54bb3e0b918665b7b2ddc44c9"></a><!-- doxytag: member="t38_core_state_s::rx_indicator_handler" ref="a7b0e8b54bb3e0b918665b7b2ddc44c9" args="" -->
t38_rx_indicator_handler_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a7b0e8b54bb3e0b918665b7b2ddc44c9">rx_indicator_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler routine to process received indicator packets. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aaeb8eeab2f0f24f0344f86ce45eaa1b"></a><!-- doxytag: member="t38_core_state_s::rx_data_handler" ref="aaeb8eeab2f0f24f0344f86ce45eaa1b" args="" -->
t38_rx_data_handler_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#aaeb8eeab2f0f24f0344f86ce45eaa1b">rx_data_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler routine to process received data packets. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42be02041eca60dc6d1bd4777a823b57"></a><!-- doxytag: member="t38_core_state_s::rx_missing_handler" ref="42be02041eca60dc6d1bd4777a823b57" args="" -->
t38_rx_missing_handler_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#42be02041eca60dc6d1bd4777a823b57">rx_missing_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler routine to process the missing packet condition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5aefab3fc56df2b7b11af6548d1eea99"></a><!-- doxytag: member="t38_core_state_s::rx_user_data" ref="5aefab3fc56df2b7b11af6548d1eea99" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#5aefab3fc56df2b7b11af6548d1eea99">rx_user_data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An opaque pointer passed to any of the above receive handling routines. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e58b4f44ce83c739a0664e9016070d03"></a><!-- doxytag: member="t38_core_state_s::data_rate_management_method" ref="e58b4f44ce83c739a0664e9016070d03" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#e58b4f44ce83c739a0664e9016070d03">data_rate_management_method</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method 1: Local generation of TCF (required for use with TCP). Method 2: Transfer of TCF is required for use with UDP (UDPTL or RTP). Method 2 is not recommended for use with TCP. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="44698e74f3c2a76bb0501dae7765312c"></a><!-- doxytag: member="t38_core_state_s::data_transport_protocol" ref="44698e74f3c2a76bb0501dae7765312c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#44698e74f3c2a76bb0501dae7765312c">data_transport_protocol</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The emitting gateway may indicate a preference for either UDP/UDPTL, or UDP/RTP, or TCP for transport of T.38 IFP Packets. The receiving device selects the transport protocol. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d57264b0607c5a2f3263665ae5a5e25"></a><!-- doxytag: member="t38_core_state_s::fill_bit_removal" ref="3d57264b0607c5a2f3263665ae5a5e25" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#3d57264b0607c5a2f3263665ae5a5e25">fill_bit_removal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates the capability to remove and insert fill bits in Phase C, non-ECM data to reduce bandwidth in the packet network. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4e6a345a1ce6e3fbf58b430b2073b71"></a><!-- doxytag: member="t38_core_state_s::mmr_transcoding" ref="e4e6a345a1ce6e3fbf58b430b2073b71" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#e4e6a345a1ce6e3fbf58b430b2073b71">mmr_transcoding</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates the ability to convert to/from MMR from/to the line format to improve the compression of the data, and reduce the bandwidth, in the packet network. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0cd00237f92ce9900494a2547bf4821"></a><!-- doxytag: member="t38_core_state_s::jbig_transcoding" ref="a0cd00237f92ce9900494a2547bf4821" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a0cd00237f92ce9900494a2547bf4821">jbig_transcoding</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates the ability to convert to/from JBIG to reduce bandwidth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="200596ca646c839ab467e80c8c8180b8"></a><!-- doxytag: member="t38_core_state_s::max_buffer_size" ref="200596ca646c839ab467e80c8c8180b8" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#200596ca646c839ab467e80c8c8180b8">max_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For UDP (UDPTL or RTP) modes, this option indicates the maximum number of octets that can be stored on the remote device before an overflow condition occurs. It is the responsibility of the transmitting application to limit the transfer rate to prevent an overflow. The negotiated data rate should be used to determine the rate at which data is being removed from the buffer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="591708157ff8450d1a7d2d3f960b897f"></a><!-- doxytag: member="t38_core_state_s::max_datagram_size" ref="591708157ff8450d1a7d2d3f960b897f" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#591708157ff8450d1a7d2d3f960b897f">max_datagram_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This option indicates the maximum size of a UDPTL packet or the maximum size of the payload within an RTP packet that can be accepted by the remote device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6d16721b1fd85267746c57617d917ac"></a><!-- doxytag: member="t38_core_state_s::t38_version" ref="b6d16721b1fd85267746c57617d917ac" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#b6d16721b1fd85267746c57617d917ac">t38_version</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the version number of ITU-T Rec. T.38. New versions shall be compatible with previous versions. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7e6f7466214b488652c6d29580795cf"></a><!-- doxytag: member="t38_core_state_s::allow_for_tep" ref="f7e6f7466214b488652c6d29580795cf" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#f7e6f7466214b488652c6d29580795cf">allow_for_tep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow time for TEP playout. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3448607e4450ab552011a94ccf6d397e"></a><!-- doxytag: member="t38_core_state_s::fastest_image_data_rate" ref="3448607e4450ab552011a94ccf6d397e" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#3448607e4450ab552011a94ccf6d397e">fastest_image_data_rate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The fastest data rate supported by the T.38 channel. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd73275da657881cae1e9e3c318eb09c"></a><!-- doxytag: member="t38_core_state_s::category_control" ref="dd73275da657881cae1e9e3c318eb09c" args="[5]" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#dd73275da657881cae1e9e3c318eb09c">category_control</a> [5]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of times each packet type will be sent (low byte). The depth of redundancy (2nd byte). Higher numbers may increase reliability for UDP transmission. Zero is valid for the indicator packet category, to suppress all indicator packets (typicaly for TCP transmission). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f09ff583f8003b177dce9a53b2a908fb"></a><!-- doxytag: member="t38_core_state_s::check_sequence_numbers" ref="f09ff583f8003b177dce9a53b2a908fb" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#f09ff583f8003b177dce9a53b2a908fb">check_sequence_numbers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TRUE if IFP packet sequence numbers are relevant. For some transports, like TPKT over TCP they are not relevent. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14dc01861e3c4b27b1cc37280e1d00e0"></a><!-- doxytag: member="t38_core_state_s::tx_seq_no" ref="14dc01861e3c4b27b1cc37280e1d00e0" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#14dc01861e3c4b27b1cc37280e1d00e0">tx_seq_no</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The sequence number for the next packet to be transmitted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68885dd09006e5b99a9d1a591d05ecfe"></a><!-- doxytag: member="t38_core_state_s::rx_expected_seq_no" ref="68885dd09006e5b99a9d1a591d05ecfe" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#68885dd09006e5b99a9d1a591d05ecfe">rx_expected_seq_no</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The sequence number expected in the next received packet. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfa8b9c0e0682e86a27b7945480dab2b"></a><!-- doxytag: member="t38_core_state_s::current_rx_indicator" ref="cfa8b9c0e0682e86a27b7945480dab2b" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#cfa8b9c0e0682e86a27b7945480dab2b">current_rx_indicator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current receive indicator - i.e. the last indicator received. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cbfa434301767c595d4371a9d030644c"></a><!-- doxytag: member="t38_core_state_s::current_rx_data_type" ref="cbfa434301767c595d4371a9d030644c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#cbfa434301767c595d4371a9d030644c">current_rx_data_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current receive data type - i.e. the last data type received. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10f85116e12b795a4931a92a90c020de"></a><!-- doxytag: member="t38_core_state_s::current_rx_field_type" ref="10f85116e12b795a4931a92a90c020de" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#10f85116e12b795a4931a92a90c020de">current_rx_field_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current receive field type - i.e. the last field_type received. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f1503d03f3169ffa58146878081e049"></a><!-- doxytag: member="t38_core_state_s::current_tx_indicator" ref="0f1503d03f3169ffa58146878081e049" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#0f1503d03f3169ffa58146878081e049">current_tx_indicator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current transmit indicator - i.e. the last indicator transmitted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9298e6542d3148bb819728c1236c861"></a><!-- doxytag: member="t38_core_state_s::v34_rate" ref="a9298e6542d3148bb819728c1236c861" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a9298e6542d3148bb819728c1236c861">v34_rate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bit rate for V.34 operation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#13ae1bb629594293f9d3ced2a5275020">missing_packets</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4205c9b08dec0f7387b77899d146076"></a><!-- doxytag: member="t38_core_state_s::logging" ref="d4205c9b08dec0f7387b77899d146076" args="" -->
<a class="el" href="structlogging__state__s.html">logging_state_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#d4205c9b08dec0f7387b77899d146076">logging</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error and flow logging control. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Core T.38 state, common to all modes of T.38. 
<p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="13ae1bb629594293f9d3ced2a5275020"></a><!-- doxytag: member="t38_core_state_s::missing_packets" ref="13ae1bb629594293f9d3ced2a5275020" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structt38__core__state__s.html#13ae1bb629594293f9d3ced2a5275020">t38_core_state_s::missing_packets</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A count of missing receive packets. This count might not be accurate if the received packet numbers jump wildly. 
</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="private_2t38__core_8h-source.html">private/t38_core.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Mar 17 10:16:38 2010 for spandsp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
