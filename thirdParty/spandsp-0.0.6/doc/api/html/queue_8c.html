<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spandsp: queue.c File Reference</title>
<link href="css.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_0e7c2593c17df2b8598d85d379ada763.html">src</a></div>
<h1>queue.c File Reference</h1><code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;time.h&gt;</code><br>
<code>#include &lt;ctype.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;inttypes.h&gt;</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>
<code>#include &quot;spandsp/telephony.h&quot;</code><br>
<code>#include &quot;<a class="el" href="queue_8h-source.html">spandsp/queue.h</a>&quot;</code><br>
<code>#include &quot;spandsp/private/queue.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#41c94445a43d382dbe9f4d0ec8badd9d">queue_empty</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a queue is empty.  <a href="#41c94445a43d382dbe9f4d0ec8badd9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#9eb332d024d432847f06efd077eb5078">queue_free_space</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check available free space.  <a href="#9eb332d024d432847f06efd077eb5078"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#8f0bfa30cb955e907fb8dc21a229b14d">queue_contents</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the contents of a queue.  <a href="#8f0bfa30cb955e907fb8dc21a229b14d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#8ed639624d4d89cf44ccda8411e40bf1">queue_flush</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the contents of a queue.  <a href="#8ed639624d4d89cf44ccda8411e40bf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#79d889aaf1f2696e389b722e454961d8">queue_view</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, uint8_t *buf, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy bytes from a queue.  <a href="#79d889aaf1f2696e389b722e454961d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#068447b1559f1c712a6344b035215d24">queue_read</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, uint8_t *buf, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read bytes from a queue.  <a href="#068447b1559f1c712a6344b035215d24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#0fb7687cc0e81e18a766faae6515b70d">queue_read_byte</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a byte from a queue.  <a href="#0fb7687cc0e81e18a766faae6515b70d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#2f1ed7d5e6755bf2eb98d45914eb9305">queue_write</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, const uint8_t *buf, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write bytes to a queue.  <a href="#2f1ed7d5e6755bf2eb98d45914eb9305"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#def34edd99f8c6d953b19daee991e2f2">queue_write_byte</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, uint8_t byte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a byte to a queue.  <a href="#def34edd99f8c6d953b19daee991e2f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#5210c6b968c9aad97871ddcf9944c9d1">queue_state_test_msg</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test message length.  <a href="#5210c6b968c9aad97871ddcf9944c9d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#01d5589971fc8788a34d375d62539fce">queue_read_msg</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, uint8_t *buf, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a message from a queue.  <a href="#01d5589971fc8788a34d375d62539fce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#d4455873c76e945f29e45f63a9ebcac3">queue_write_msg</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, const uint8_t *buf, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a message to a queue.  <a href="#d4455873c76e945f29e45f63a9ebcac3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#3ecee7280232cb38f85a89cbe3b8db28">queue_init</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s, int len, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a queue.  <a href="#3ecee7280232cb38f85a89cbe3b8db28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#18010f4b0f9e19a49790c0e8cc9e1e2f">queue_release</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a queue.  <a href="#18010f4b0f9e19a49790c0e8cc9e1e2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="queue_8c.html#a91afa289298903b85e594e57c3736be">queue_free</a> (<a class="el" href="structqueue__state__s.html">queue_state_t</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a queue.  <a href="#a91afa289298903b85e594e57c3736be"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8f0bfa30cb955e907fb8dc21a229b14d"></a><!-- doxytag: member="queue.c::queue_contents" ref="8f0bfa30cb955e907fb8dc21a229b14d" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_contents           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the contents of a queue. 
<p>
Check the contents of a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes in the queue. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41c94445a43d382dbe9f4d0ec8badd9d"></a><!-- doxytag: member="queue.c::queue_empty" ref="41c94445a43d382dbe9f4d0ec8badd9d" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_empty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a queue is empty. 
<p>
Check if a queue is empty. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if empty, else FALSE. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ed639624d4d89cf44ccda8411e40bf1"></a><!-- doxytag: member="queue.c::queue_flush" ref="8ed639624d4d89cf44ccda8411e40bf1" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_flush           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush the contents of a queue. 
<p>
Flush the contents of a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a91afa289298903b85e594e57c3736be"></a><!-- doxytag: member="queue.c::queue_free" ref="a91afa289298903b85e594e57c3736be" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a queue. 
<p>
Free a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, else -1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9eb332d024d432847f06efd077eb5078"></a><!-- doxytag: member="queue.c::queue_free_space" ref="9eb332d024d432847f06efd077eb5078" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_free_space           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check available free space. 
<p>
Check the available free space in a queue's buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of free space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ecee7280232cb38f85a89cbe3b8db28"></a><!-- doxytag: member="queue.c::queue_init" ref="3ecee7280232cb38f85a89cbe3b8db28" args="(queue_state_t *s, int len, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structqueue__state__s.html">queue_state_t</a>* queue_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise a queue. 
<p>
Initialise a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. If is imperative that the context this points to is immediately followed by a buffer of the required size + 1 octet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the queue's buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags controlling the operation of the queue. Valid flags are QUEUE_READ_ATOMIC and QUEUE_WRITE_ATOMIC. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the context if OK, else NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="068447b1559f1c712a6344b035215d24"></a><!-- doxytag: member="queue.c::queue_read" ref="068447b1559f1c712a6344b035215d24" args="(queue_state_t *s, uint8_t *buf, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read bytes from a queue. 
<p>
Read bytes from a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer into which the bytes will be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0fb7687cc0e81e18a766faae6515b70d"></a><!-- doxytag: member="queue.c::queue_read_byte" ref="0fb7687cc0e81e18a766faae6515b70d" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_read_byte           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a byte from a queue. 
<p>
Read a byte from a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the byte, or -1 if the queue is empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01d5589971fc8788a34d375d62539fce"></a><!-- doxytag: member="queue.c::queue_read_msg" ref="01d5589971fc8788a34d375d62539fce" args="(queue_state_t *s, uint8_t *buf, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_read_msg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a message from a queue. 
<p>
Read a message from a queue. If the message is longer than the buffer provided, only the first len bytes of the message will be returned. The remainder of the message will be discarded. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer into which the message will be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes returned. If there are no messages in the queue, -1 is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18010f4b0f9e19a49790c0e8cc9e1e2f"></a><!-- doxytag: member="queue.c::queue_release" ref="18010f4b0f9e19a49790c0e8cc9e1e2f" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_release           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a queue. 
<p>
Release a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, else -1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5210c6b968c9aad97871ddcf9944c9d1"></a><!-- doxytag: member="queue.c::queue_state_test_msg" ref="5210c6b968c9aad97871ddcf9944c9d1" args="(queue_state_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_state_test_msg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test message length. 
<p>
Test the length of the message at the head of a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The length of the next message, in byte. If there are no messages in the queue, -1 is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="79d889aaf1f2696e389b722e454961d8"></a><!-- doxytag: member="queue.c::queue_view" ref="79d889aaf1f2696e389b722e454961d8" args="(queue_state_t *s, uint8_t *buf, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_view           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy bytes from a queue. 
<p>
Copy bytes from a queue. This is similar to queue_read, but the data remains in the queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer into which the bytes will be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f1ed7d5e6755bf2eb98d45914eb9305"></a><!-- doxytag: member="queue.c::queue_write" ref="2f1ed7d5e6755bf2eb98d45914eb9305" args="(queue_state_t *s, const uint8_t *buf, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_write           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write bytes to a queue. 
<p>
Write bytes to a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer containing the bytes to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes actually written. </dd></dl>

</div>
</div><p>
<a class="anchor" name="def34edd99f8c6d953b19daee991e2f2"></a><!-- doxytag: member="queue.c::queue_write_byte" ref="def34edd99f8c6d953b19daee991e2f2" args="(queue_state_t *s, uint8_t byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_write_byte           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>byte</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a byte to a queue. 
<p>
Write a byte to a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byte</em>&nbsp;</td><td>The byte to be written. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes actually written. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4455873c76e945f29e45f63a9ebcac3"></a><!-- doxytag: member="queue.c::queue_write_msg" ref="d4455873c76e945f29e45f63a9ebcac3" args="(queue_state_t *s, const uint8_t *buf, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queue_write_msg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__state__s.html">queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a message to a queue. 
<p>
Write a message to a queue. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The queue context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer from which the message will be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the message. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes actually written. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Mar 17 10:16:37 2010 for spandsp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
